
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>캘린더</title>

  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap"
    rel="stylesheet"
  >

  <style>
    :root{
      --bg:#f7f7f5;
      --card:#ffffff;
      --text:#2f3437;
      --muted:#6b6f73;
      --border:#e7e7e4;

      --primary:#2f6feb;
      --danger:#ef4444;

      --radius:14px;
      --shadow:none;

      --sidebar-w: 360px;
      --ctl-h: 34px;
    }

    *{box-sizing:border-box;}
    html, body{height:100%;}
    body{
      margin:0;
      font-family:"Noto Sans KR", system-ui, -apple-system, "Segoe UI", sans-serif;
      background:var(--bg);
      color:var(--text);
    }
    input, textarea, button, select{ font-family:inherit; }

    header{
      position:sticky;
      top:0;
      z-index:30;
      background:rgba(247,247,245,.92);
      backdrop-filter:saturate(180%) blur(10px);
      border-bottom:1px solid var(--border);
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 14px;
      gap:12px;
      max-width: 1400px;
      margin:0 auto;
    }

    .topbar-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }

    .brand{
      font-weight:800;
      letter-spacing:-0.2px;
      padding:6px 10px;
      border-radius:10px;
      background:#fff;
      border:1px solid var(--border);
      flex:0 0 auto;
    }

    .divider{
      width:1px;
      height:18px;
      background:var(--border);
      flex:0 0 auto;
    }

    .nav-btn{
      height:34px;
      padding:0 10px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      font-weight:700;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
      flex:0 0 auto;
    }
    .nav-btn:hover{background:#f2f2f0;}

    .ym-label{
      font-size:16px;
      font-weight:800;
      letter-spacing:-0.2px;
      padding:0 4px;
      white-space:nowrap;
      flex:0 0 auto;
    }

    .topbar-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex:0 0 auto;
    }

    .view-switch{
      display:flex;
      align-items:center;
      gap:6px;
      padding:4px;
      border-radius:12px;
      border:1px solid var(--border);
      background:#fff;
    }
    .view-btn{
      height:30px;
      padding:0 10px;
      border-radius:10px;
      border:0;
      background:transparent;
      color:var(--muted);
      font-weight:800;
      cursor:pointer;
    }
    .view-btn:hover{background:#f2f2f0; color:var(--text);}
    .view-btn.active{
      background:rgba(47,52,55,.10);
      color:var(--text);
    }

    .header-actions{
      display:flex;
      align-items:center;
      gap:8px;
      padding-left:4px;
    }
    .badge{
      display:inline-flex;
      align-items:center;
      padding:.25rem .55rem;
      border-radius:999px;
      font-size:.78rem;
      font-weight:800;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      white-space:nowrap;
    }
    .badge.linked{
      background:#eaf6ee;
      border-color:#c8e9d3;
      color:#1f6f3d;
    }
    .badge.admin{
      background:#fff3d8;
      border-color:#ffe1a6;
      color:#7a4b00;
    }
    .header-btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      padding:.32rem .62rem;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      text-decoration:none;
      font-size:.82rem;
      font-weight:800;
      white-space:nowrap;
    }
    .header-btn:hover{ background:#f2f2f0; }

    /* ===== Layout: calendar left, utilities right ===== */
    .app{
      display:grid;
      grid-template-columns: 1fr var(--sidebar-w);
      gap:12px;
      padding:12px;
      max-width: 1400px;
      margin:0 auto;
      align-items:start;
    }

    main{min-width:0;}
    aside{
      position:sticky;
      top:62px;
      align-self:start;
      height: calc(100vh - 74px);
      overflow:auto;
      padding-right:2px;
    }

    .panel{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:12px;
      margin-bottom:12px;
    }

    .panel-title{
      display:flex;
      align-items:baseline;
      justify-content:space-between;
      gap:10px;
      margin:0 0 10px;
    }
    .panel-title h2{
      margin:0;
      font-size:13px;
      font-weight:900;
      letter-spacing:-0.2px;
      color:var(--text);
    }
    .panel-title .sub{
      font-size:12px;
      color:var(--muted);
      font-weight:800;
      white-space:nowrap;
      display:flex;
      align-items:center;
      gap:6px;
    }
    .panel-title .sub-divider{
      color:var(--border);
      font-weight:900;
    }
    #selected-date-label{
      display:inline-flex;
      align-items:center;
      padding:2px 10px;
      border-radius:999px;
      background:rgba(47,111,235,.15);
      color:#1c3b7a;
      font-weight:900;
      letter-spacing:-0.2px;
    }
    #selected-count-label{
      font-weight:900;
      color:var(--text);
    }

    /* ===== Calendar ===== */
    #calendar-container{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:10px;
      position:relative;
      overflow:hidden;
    }
    .calendar-main-content{
      position:relative;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:100%;
      transition:filter .4s ease;
    }
    #calendar-container .calendar-events-panel{
      margin:0;
    }

    #calendar .fc{
      font-size:0.92rem;
      color:var(--text);
    }
    #calendar .fc .fc-view-harness{
      min-height:0 !important;
    }
    #calendar .fc-theme-standard td,
    #calendar .fc-theme-standard th{
      border-color:var(--border);
    }
    #calendar .fc-scrollgrid{ border:0; }
    #calendar .fc-col-header-cell-cushion{
      font-weight:900;
      color:var(--muted);
      padding:10px 6px;
    }
    #calendar .fc-daygrid-day-number{
      font-weight:900;
      color:var(--text);
      padding:7px 8px;
    }
    #calendar .fc-day-today{
      background: rgba(47,52,55,.04) !important;
    }
    #calendar .fc .fc-daygrid-event{
      background:transparent;
      border:0;
      color:var(--text);
      padding:2px 6px 2px 18px;
      border-radius:8px;
      position:relative;
    }
    #calendar .fc .fc-daygrid-event:hover{ background:#f2f2f0; }
    #calendar .fc .fc-daygrid-event::before{
      content:"";
      width:6px;
      height:6px;
      border-radius:50%;
      background:var(--primary);
      position:absolute;
      left:8px;
      top:50%;
      transform:translateY(-50%);
      opacity:.9;
    }
    #calendar .fc .fc-daygrid-event .fc-event-title{ font-weight:900; }
    #calendar .fc .fc-daygrid-more-link{
      color:var(--muted);
      font-weight:900;
    }
    #calendar .fc .fc-daygrid-more-link:hover{ color:var(--text); }

    /* ✅ 선택 날짜 하이라이트 */
    #calendar .fc-daygrid-day.selected-day{
      background: rgba(47,111,235,.10) !important;
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-day-frame{
      border-radius: 10px;
      box-shadow: inset 0 0 0 2px rgba(47,111,235,.28);
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-day-number{
      color:#1d3360 !important;
      font-weight:900;
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-event{
      background: rgba(47,111,235,.18);
      color:#15233c;
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-event::before{
      background:#1c3b7a;
    }
    #calendar .fc .selected-day-header{
      background: rgba(47,111,235,.10);
      color:#1d3360;
      font-weight:900;
    }
    #calendar .fc .fc-timegrid-col.selected-day .fc-timegrid-col-frame{
      background: rgba(47,111,235,.08);
      box-shadow: inset 0 0 0 2px rgba(47,111,235,.2);
    }
    #calendar .fc .fc-timegrid-col.selected-day .fc-timegrid-event{
      background: rgba(47,111,235,.2);
      border-color: rgba(47,111,235,.3);
      color:#15233c;
    }

    body.global-loading-active #calendar-container .calendar-main-content{
      filter:blur(10px);
      pointer-events:none;
    }
    body.global-loading-active #calendar-container #global-loading-overlay{
      filter:none;
    }


    /* ===== NLP Composer ===== */
    .composer textarea{
      width:100%;
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 10px 44px 10px;
      font-size:14px;
      line-height:1.45;
      outline:none;
      resize:none;
      background:#fff;
      color:var(--text);
      min-height:56px;
      height:56px;
      overflow:hidden;
      transition: height .18s cubic-bezier(.25,.8,.25,1);
    }
    .composer textarea:focus{ border-color: rgba(47,52,55,.35); }

    .composer-controls{
      position:relative;
      margin-top:-40px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:0 8px 6px;
      pointer-events:none;
    }
    .composer-controls > *{ pointer-events:auto; }

    .seg-toggle{
      display:inline-flex;
      align-items:center;
      gap:0;
      border:1px solid var(--border);
      background:#fff;
      border-radius:12px;
      padding:3px;
      height:32px;
    }
    .seg-toggle input{ display:none; }
    .seg{
      height:26px;
      padding:0 10px;
      border-radius:10px;
      display:inline-flex;
      align-items:center;
      font-weight:900;
      font-size:12px;
      color:var(--muted);
      cursor:pointer;
      user-select:none;
    }
    #nlp-mode-toggle:not(:checked) ~ .seg.add{
      background:rgba(47,52,55,.10);
      color:var(--text);
    }
    #nlp-mode-toggle:checked ~ .seg.del{
      background:rgba(239,68,68,.12);
      color:#8a1f1f;
    }

    .inline-action{
      position:relative;
      width:var(--ctl-h);
      height:var(--ctl-h);
      flex:0 0 auto;
    }
    .inline-action > *{ position:absolute; inset:0; }

    .Btn{
      width:var(--ctl-h);
      height:var(--ctl-h);
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:transform .15s ease, background .15s ease, opacity .35s ease;
    }
    .Btn:hover{ background:#f2f2f0; }
    .Btn:active{ transform:translateY(1px); }
    .Btn.mode-delete{ border-color: rgba(239,68,68,.35); }

    .Btn .sign svg{ width:16px; height:16px; }
    .Btn .sign svg path{ fill: var(--text); }
    .Btn.mode-delete .sign svg path{ fill: #8a1f1f; }

    .scale-0{transform:scale(.95); opacity:0; pointer-events:none;}
    .scale-1{transform:scale(1); opacity:1;}

    .loader-wrapper{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      transition:opacity .35s ease, transform .35s ease;
    }
    .loader{
      width:18px;
      height:18px;
      border-radius:50%;
      border:2px solid rgba(47,52,55,.18);
      border-top-color: rgba(47,52,55,.55);
      animation:spin 0.9s linear infinite;
    }
    .loader.is-delete{
      border-color: rgba(239,68,68,.18);
      border-top-color: rgba(239,68,68,.6);
    }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    .attachment-bar{
      margin-top:12px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .attach-btn{
      display:inline-flex;
      align-items:center;
      gap:6px;
      height:32px;
      padding:0 12px;
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-weight:800;
      color:var(--text);
      cursor:pointer;
      font-size:13px;
    }
    .attach-btn svg{
      width:16px;
      height:16px;
      fill:currentColor;
    }
    .attach-btn:hover{ background:#f2f2f0; }
    .attach-hint{
      font-size:12px;
      color:var(--muted);
    }
    .image-attachments{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .image-chip{
      width:92px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .image-chip img{
      width:100%;
      height:60px;
      object-fit:cover;
      border-radius:8px;
      border:1px solid rgba(0,0,0,.05);
    }
    .image-chip-actions{
      display:flex;
      gap:4px;
    }
    .image-chip-actions button{
      flex:1 1 auto;
      border:1px solid var(--border);
      border-radius:8px;
      background:#fff;
      font-size:11px;
      font-weight:700;
      cursor:pointer;
      padding:2px 0;
    }
    .image-chip-actions button:hover{
      background:#f2f2f0;
    }

    #image-editor-overlay{
      position:fixed;
      inset:0;
      z-index:2000;
      background:rgba(15,18,20,.65);
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    #image-editor-overlay.active{ display:flex; }
    .image-editor-modal{
      background:#fff;
      border-radius:16px;
      width:min(920px, 96vw);
      max-height:90vh;
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:16px;
    }
    .image-editor-head{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .image-editor-title{
      font-size:18px;
      font-weight:800;
    }
    .image-editor-meta{
      font-size:13px;
      color:var(--muted);
    }
    .image-editor-canvas{
      border:1px solid var(--border);
      border-radius:14px;
      background:#f9f9f7;
      padding:12px;
      overflow:auto;
      flex:1 1 auto;
    }
    .image-editor-canvas-inner{
      position:relative;
      display:inline-block;
    }
    #image-editor-canvas,
    #image-editor-selection{
      display:block;
      max-width:100%;
      border-radius:10px;
    }
    #image-editor-selection{
      position:absolute;
      left:0;
      top:0;
      pointer-events:auto;
      cursor:crosshair;
      touch-action:none;
    }
    .image-editor-foot{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .image-editor-foot .spacer{
      flex:1 1 auto;
    }
    .image-editor-foot button{
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-weight:800;
      padding:6px 14px;
      cursor:pointer;
    }
    .image-editor-foot button.primary{
      background:var(--text);
      border-color:var(--text);
      color:#fff;
    }
    .image-editor-foot button:hover:not(.primary){
      background:#f2f2f0;
    }

    .scope-controls{
      margin-top:10px;
      padding:10px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fffaf5;
      display:none;
    }
    .scope-title{
      font-size:12px;
      font-weight:900;
      color:#7a3a00;
      margin-bottom:6px;
    }
    .scope-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .scope-row input[type="date"]{
      flex:1;
      min-width:120px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 8px;
      font-size:13px;
      font-weight:700;
    }

    .reasoning-controls{
      margin-top:10px;
      padding:10px;
      border:1px dashed var(--border);
      border-radius:12px;
      background:#f0f4ff;
      display:none;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .reasoning-controls label{
      font-size:12px;
      font-weight:900;
      color:#1c3b7a;
    }
    .reasoning-controls select{
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 10px;
      font-size:13px;
      font-weight:700;
      background:#fff;
      min-width:120px;
    }

    .rec-end-box{
      margin-top:10px;
      padding:10px;
      border:1px dashed var(--border);
      border-radius:12px;
      background:#fffdf5;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .rec-end-box h3{
      margin:0;
      font-size:12px;
      font-weight:900;
      color:#7a3a00;
    }
    .rec-end-options{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .rec-end-option{
      display:flex;
      align-items:center;
      gap:4px;
      font-size:12px;
      font-weight:800;
      color:#4a3b21;
    }
    .rec-end-extra{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .rec-end-extra input[type="date"],
    .rec-end-extra input[type="number"]{
      border:1px solid var(--border);
      border-radius:8px;
      padding:4px 8px;
      font-size:12px;
      font-weight:800;
      min-width:140px;
    }

    /* ===== Quick add ===== */
    /* ===== Selected date list ===== */
  #events-ul{list-style:none; padding:0; margin:0;}
  #events-ul li{
    padding:10px 6px;
    border-bottom:1px solid var(--border);
    display:flex;
    align-items:center;
    gap:10px;
    cursor:pointer;
  }
  .event-dot{
    width:8px;
    height:8px;
      border-radius:50%;
      background:var(--primary);
      flex:0 0 auto;
      margin-top:2px;
    }
    .event-info{flex:1; min-width:0;}
    .event-title{
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .event-meta{
      color:var(--muted);
      font-size:12px;
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
  .delete-btn{
    border:1px solid var(--border);
    background:#fff;
    color:var(--muted);
    font-weight:900;
      border-radius:10px;
      padding:7px 10px;
      cursor:pointer;
      flex:0 0 auto;
    }
  .delete-btn:hover{
    border-color: rgba(239,68,68,.35);
    color:#8a1f1f;
    background: rgba(239,68,68,.06);
  }
  .fc-event,
  .fc-daygrid-event,
  .fc-timegrid-event{
    cursor:pointer;
  }

    /* ===== Confirm Modal ===== */
    #confirm-overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.28);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:60;
    }
    #confirm-modal{
      width:min(560px, 100%);
      background:#fff;
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      overflow:hidden;
    }
    .cm-head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      padding:14px 14px 10px;
      border-bottom:1px solid var(--border);
    }
    .cm-title{ font-weight:900; font-size:14px; }
    .cm-desc{
      margin-top:4px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      line-height:1.4;
    }
    .cm-x{
      border:1px solid var(--border);
      background:#fff;
      border-radius:10px;
      width:34px;
      height:34px;
      cursor:pointer;
      font-weight:900;
    }
    .cm-x:hover{ background:#f2f2f0; }
    .cm-body{
      padding:12px 14px;
      max-height: 56vh;
      overflow:auto;
    }
    .cm-foot{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding:12px 14px;
      border-top:1px solid var(--border);
      background: #fafaf9;
    }
    .cm-btn{
      border-radius:12px;
      border:1px solid var(--border);
      padding:10px 12px;
      font-weight:900;
      cursor:pointer;
      background:#fff;
    }
    .cm-btn:hover{ background:#f2f2f0; }
    .cm-btn.primary{
      background: rgba(47,52,55,.10);
    }
    .cm-btn.primary:hover{
      background: rgba(47,52,55,.14);
    }

    .primary-btn{
      height:38px;
      padding:0 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: rgba(47,52,55,.10);
      color:var(--text);
      font-weight:900;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      margin-top:8px;
      transition:background .2s ease, opacity .2s ease;
    }
    .primary-btn:hover{ background: rgba(47,52,55,.14); }
    .primary-btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      background: rgba(47,52,55,.08);
    }

    .cm-row{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 10px;
      margin-bottom:8px;
      background:#fff;
    }
    .cm-row-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .cm-left{
      display:flex;
      gap:10px;
      align-items:flex-start;
      min-width:0;
    }
    .cm-check{ margin-top:2px; }
    .cm-main{ min-width:0; }
    .cm-line1{
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .cm-line2{
      margin-top:2px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .cm-line-location{
      margin-top:4px;
      font-size:12px;
      font-weight:800;
      color:var(--muted);
    }
    .cm-mini{
      margin-top:6px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
    }
    .cm-toggle{
      border:1px solid var(--border);
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      font-weight:900;
      cursor:pointer;
      color:var(--muted);
      white-space:nowrap;
    }
    .cm-toggle:hover{ background:#f2f2f0; color:var(--text); }
    .cm-sublist{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid var(--border);
      display:none;
    }
    .cm-subitem{
      display:flex;
      align-items:flex-start;
      gap:10px;
      padding:8px 6px;
      border-radius:10px;
    }
  .cm-subitem:hover{ background:#f7f7f5; }

  .cm-editable{
    display:inline-flex;
    align-items:center;
    gap:6px;
    cursor:pointer;
    font-weight:900;
  }
  .cm-editable.editing{
    cursor:text;
  }
  .cm-editable input{
    border:1px solid var(--border);
    border-radius:8px;
    padding:4px 6px;
    font-size:13px;
    font-weight:800;
    width:160px;
  }
  .cm-edit-icon{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:18px;
    height:18px;
    border:0;
    background:transparent;
    padding:0;
  }
  .cm-edit-icon svg{
    width:14px;
    height:14px;
    fill:var(--muted);
  }
  .cm-editable:hover .cm-edit-icon svg{
    fill:var(--text);
  }

  #global-loading-overlay{
    position:absolute;
    inset:0;
    background:rgba(0,0,0,.25);
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:20;
    opacity:0;
    pointer-events:none;
    transition:opacity .2s ease;
  }
  #global-loading-overlay.active{
    opacity:1;
    pointer-events:auto;
  }
  .global-loading-box{
    background:#fff;
    color:var(--text);
    padding:18px 22px;
    border-radius:14px;
    border:1px solid var(--border);
    box-shadow:0 8px 20px rgba(0,0,0,.12);
    display:flex;
    align-items:center;
    justify-content:center;
    margin:0 auto;
    min-width:200px;
    text-align:center;
    font-weight:800;
  }
  .global-loading-text{
    font-size:14px;
    line-height:1.4;
  }

  #event-modal-overlay{
    position:fixed;
    inset:0;
    background:rgba(0,0,0,.35);
    display:none;
    align-items:center;
    justify-content:center;
    padding:14px;
    z-index:70;
  }
  #event-modal-overlay.active{ display:flex; }
  #event-modal{
    width:min(520px, 96vw);
    background:#fff;
    border:1px solid var(--border);
    border-radius:16px;
    padding:16px;
    display:flex;
    flex-direction:column;
    gap:16px;
  }
  .event-modal-head{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
  }
  .event-modal-title{
    font-size:18px;
    font-weight:900;
    margin-bottom:4px;
  }
  .event-modal-head button{
    border:0;
    background:transparent;
    cursor:pointer;
    font-size:20px;
  }
  .event-modal-body{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .event-field{
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .event-field label{
    font-size:12px;
    font-weight:800;
    color:var(--muted);
  }
  .event-field input,
  .event-field textarea,
  .event-field select{
    border:1px solid var(--border);
    border-radius:10px;
    padding:8px;
    font-size:14px;
    font-family:inherit;
  }
  .event-field-row{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .event-modal-foot{
    display:flex;
    justify-content:flex-end;
    gap:10px;
  }
  .event-modal-foot button{
    border-radius:10px;
    border:1px solid var(--border);
    background:#fff;
    font-weight:800;
    padding:6px 12px;
    cursor:pointer;
  }
  .event-modal-foot button.primary{
    background:var(--text);
    color:#fff;
    border-color:var(--text);
  }
  .event-modal-foot button:hover:not(.primary){
    background:#f2f2f0;
  }

    /* Recent modal */
    #recent-overlay{
      position:fixed;
      inset:0;
      background: rgba(0,0,0,.28);
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:65;
    }
    #recent-modal{
      width:min(560px, 100%);
      background:#fff;
      border:1px solid var(--border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      overflow:hidden;
    }
    .recent-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px;
      border-bottom:1px solid var(--border);
    }
    .recent-title{ font-weight:900; font-size:14px; }
    .recent-body{
      max-height:60vh;
      overflow:auto;
      padding:10px 14px;
    }
    .recent-item{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px;
      margin-bottom:8px;
      display:flex;
      align-items:flex-start;
      gap:10px;
      background:#fff;
    }
    .recent-item .badge{
      background:#eaf2ff;
      border-color:#d2e1ff;
      color:#1d3360;
    }
    .recent-main{ flex:1; min-width:0; }
    .recent-line1{
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .recent-line2{
      margin-top:3px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .recent-meta{
      margin-top:4px;
      color:var(--muted);
      font-weight:700;
      font-size:11px;
    }
    .recent-delete{
      border:1px solid var(--border);
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      font-weight:900;
      color:#8a1f1f;
      cursor:pointer;
      flex:0 0 auto;
    }
    .recent-delete:hover{
      background:#fdf2f2;
      border-color: rgba(239,68,68,.4);
    }
    .recent-foot{
      padding:12px 14px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:flex-end;
    }
    .recent-close{
      border:1px solid var(--border);
      border-radius:10px;
      padding:9px 12px;
      background:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .recent-close:hover{ background:#f2f2f0; }

    @media (max-width: 980px){
      .app{ grid-template-columns: 1fr; }
      aside{ position:relative; top:auto; height:auto; }
      :root{ --sidebar-w: 1fr; }
    }
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div class="topbar-left">
      <div class="brand">Calendar</div>
      <div class="divider"></div>

      <button class="nav-btn" id="cal-prev" type="button" aria-label="이전"><span aria-hidden="true">←</span></button>
      <button class="nav-btn" id="cal-today" type="button">오늘</button>
      <button class="nav-btn" id="cal-next" type="button" aria-label="다음"><span aria-hidden="true">→</span></button>

      <div class="ym-label" id="ym-label"></div>
    </div>

    <div class="topbar-right">
      <div class="view-switch" role="tablist" aria-label="뷰 전환">
        <button class="view-btn active" type="button" data-cal-view="dayGridMonth" id="cal-view-month">월</button>
        <button class="view-btn" type="button" data-cal-view="timeGridWeek" id="cal-view-week">주</button>
        <button class="view-btn" type="button" data-cal-view="timeGridDay" id="cal-view-day">일</button>
      </div>

      <button class="header-btn" id="recent-added-btn" type="button">최근 추가한 일정</button>
      <div class="header-actions">__HEADER_ACTIONS__</div>
    </div>
  </div>
</header>

<div class="app">
  <!-- Calendar LEFT -->
  <main>
    <div id="calendar-container">
      <div class="calendar-main-content">
        <div id="calendar"></div>
        <div class="panel calendar-events-panel" id="events-list">
          <div class="panel-title">
            <h2>선택한 날짜 일정</h2>
            <div class="sub">
              <span id="selected-date-label"></span>
              <span class="sub-divider">·</span>
              <span id="selected-count-label"></span>
            </div>
          </div>
          <ul id="events-ul"></ul>
        </div>
      </div>
      <div id="global-loading-overlay" aria-hidden="true">
        <div class="global-loading-box">
          <div class="global-loading-text">불러오는 중..</div>
        </div>
      </div>
    </div>
  </main>

  <!-- Utilities RIGHT -->
  <aside id="sidebar">

    <div class="panel composer">
      <div class="panel-title">
        <h2>자연어로 추가/삭제</h2>
        <div class="sub">Enter 실행 · Shift+Enter 줄바꿈</div>
      </div>

      <textarea
        id="nlp-unified-text"
        placeholder="어떤 일정이든 입력하세요"
        rows="1"
      ></textarea>

      <div class="composer-controls">
        <label class="seg-toggle" title="추가/삭제 전환">
          <input type="checkbox" id="nlp-mode-toggle"/>
          <span class="seg add">추가</span>
          <span class="seg del">삭제</span>
        </label>

        <div class="inline-action">
          <button
            type="button"
            id="nlp-action-btn"
            class="Btn mode-add scale-1"
            aria-label="문장으로 일정 추가/삭제"
            title="실행"
          >
            <div class="sign">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 5c.55 0 1 .45 1 1v5h5c.55 0 1 .45 1 1s-.45 1-1 1h-5v5c0 .55-.45 1-1 1s-1-.45-1-1v-5H6c-.55 0-1-.45-1-1s.45-1 1-1h5V6c0-.55.45-1 1-1z"/>
              </svg>
            </div>
          </button>

          <div class="loader-wrapper scale-0" id="nlp-unified-loader">
            <div class="loader"></div>
          </div>
        </div>
      </div>

      <div class="attachment-bar">
        <button type="button" class="attach-btn" id="nlp-attach-btn">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M16.5 6.5v8.25a4.25 4.25 0 0 1-8.5 0V5a2.5 2.5 0 0 1 5 0v8a.75.75 0 0 1-1.5 0V6.5H10V13a2.5 2.5 0 0 0 5 0V5a4 4 0 0 0-8 0v9.75a5.75 5.75 0 0 0 11.5 0V6.5h-2z"/>
          </svg>
          이미지 첨부
        </button>
        <div class="attach-hint">최대 5장 · 민감한 영역은 직접 가리고 업로드</div>
        <input type="file" id="nlp-image-input" accept="image/*" multiple hidden>
      </div>
      <div class="image-attachments" id="nlp-image-attachments"></div>

      <div class="scope-controls" id="delete-scope-controls">
        <div class="scope-title">삭제 범위 (최대 1년)</div>
        <div class="scope-row">
          <input type="date" id="delete-scope-start" aria-label="삭제 범위 시작">
          <span style="font-weight:900;">~</span>
          <input type="date" id="delete-scope-end" aria-label="삭제 범위 종료">
        </div>
      </div>

      <div class="reasoning-controls" id="reasoning-effort-control">
        <label for="reasoning-effort-select">추론 강도</label>
        <select id="reasoning-effort-select">
          <option value="low">낮음</option>
          <option value="medium">보통</option>
          <option value="high">높음</option>
        </select>
      </div>

      <button type="button" class="primary-btn" id="undo-last-btn" disabled>되돌리기</button>

    </div>

  </aside>
</div>

<!-- Confirm Modal -->
<div id="confirm-overlay">
  <div id="confirm-modal" role="dialog" aria-modal="true">
    <div class="cm-head">
      <div>
        <div class="cm-title" id="confirm-title"></div>
        <div class="cm-desc" id="confirm-desc"></div>
      </div>
      <button class="cm-x" id="confirm-close" type="button">✕</button>
    </div>

    <div class="cm-body">
      <div id="confirm-list"></div>
    </div>

    <div class="cm-foot">
      <button class="cm-btn" id="confirm-cancel" type="button">취소</button>
      <button class="cm-btn primary" id="confirm-ok" type="button">적용</button>
    </div>
  </div>
</div>

<div id="event-modal-overlay">
  <div id="event-modal" role="dialog" aria-modal="true">
    <div class="event-modal-head">
      <div>
        <div class="event-modal-title" id="event-modal-title"></div>
        <div class="event-modal-sub" id="event-modal-sub"></div>
      </div>
      <button type="button" id="event-modal-close" aria-label="닫기">✕</button>
    </div>
    <div class="event-modal-body">
      <div class="event-field">
        <label for="event-modal-input-title">제목</label>
        <input type="text" id="event-modal-input-title" />
      </div>
      <div class="event-field">
        <label>시작</label>
        <div class="event-field-row">
          <input type="date" id="event-modal-input-start-date" />
          <input type="time" id="event-modal-input-start-time" />
        </div>
      </div>
      <div class="event-field">
        <label>종료</label>
        <div class="event-field-row">
          <input type="date" id="event-modal-input-end-date" />
          <input type="time" id="event-modal-input-end-time" />
        </div>
      </div>
      <div class="event-field">
        <label for="event-modal-input-location">장소</label>
        <input type="text" id="event-modal-input-location" />
      </div>
      <div class="event-field">
        <label for="event-modal-input-notes">메모</label>
        <textarea id="event-modal-input-notes" rows="2" placeholder="참고사항을 기록하세요"></textarea>
      </div>
    </div>
    <div class="event-modal-foot">
      <button type="button" id="event-modal-cancel">취소</button>
      <button type="button" class="primary" id="event-modal-save">저장</button>
    </div>
  </div>
</div>

<!-- Recent Added Modal -->
<div id="recent-overlay">
  <div id="recent-modal" role="dialog" aria-modal="true">
    <div class="recent-head">
      <div>
        <div class="recent-title">최근 추가한 일정</div>
        <div class="recent-meta" id="recent-desc">최근 14일 저장</div>
      </div>
      <button class="recent-close" id="recent-close" type="button">닫기</button>
    </div>
    <div class="recent-body" id="recent-list"></div>
    <div class="recent-foot">
      <button class="recent-close" id="recent-cancel" type="button">닫기</button>
    </div>
  </div>
</div>

<div id="image-editor-overlay" aria-hidden="true">
  <div class="image-editor-modal" role="dialog" aria-modal="true">
    <div class="image-editor-head">
      <div class="image-editor-title">이미지 가리기</div>
      <div class="image-editor-meta">드래그해서 검은 박스를 그려 민감한 정보를 가릴 수 있습니다.</div>
    </div>
    <div class="image-editor-canvas">
      <div class="image-editor-canvas-inner">
        <canvas id="image-editor-canvas"></canvas>
        <canvas id="image-editor-selection"></canvas>
      </div>
    </div>
    <div class="image-editor-foot">
      <button type="button" id="image-editor-undo">되돌리기</button>
      <div class="spacer"></div>
      <button type="button" id="image-editor-cancel">취소</button>
      <button type="button" class="primary" id="image-editor-apply">적용</button>
    </div>
  </div>
</div>

<script>
  const apiBase = "/api";
  let calendar = null;

  let selectedDateStr = null; // YYYY-MM-DD
  let nlpInputComposing = false;

  let confirmState = { mode: null, addItems: [], deleteGroups: [] };
  const MS_PER_DAY = 24 * 60 * 60 * 1000;
  const APP_CONTEXT = window.__APP_CONTEXT__ || {};
  const APP_MODE = APP_CONTEXT.mode || "local";
  const IS_GOOGLE_MODE = APP_MODE === "google";
  const IS_ADMIN = !!APP_CONTEXT.admin;
  const REASONING_EFFORT_KEY = "calendar_reasoning_effort";
  const ALLOWED_REASONING_EFFORTS = ["low","medium","high"];
  const DEFAULT_REASONING_EFFORT = "low";
  let reasoningEffortValue = DEFAULT_REASONING_EFFORT;
  const undoStack = [];
  const MAX_IMAGE_ATTACHMENTS = 5;
  const MAX_IMAGE_DIMENSION = 1600;
  const MAX_IMAGE_BYTES = 2.5 * 1024 * 1024;
  const nlpImageAttachments = [];
  let imageAttachmentSeq = 1;
  let imageEditorCanvas = null;
  let imageEditorCtx = null;
  let imageEditorOverlay = null;
  let imageEditorSelection = null;
  let imageEditorSelectionCtx = null;
  let imageEditorUndoStack = [];
  const imageEditorState = {
    attachmentId: null,
    drawing: false,
    startX: 0,
    startY: 0,
    pointerId: null
  };
  let currentEventModalContext = null;
  const googleEventCache = {};
  const googleEventFetches = {};
  let googleCacheDirty = false;
  let googleCacheGeneration = 0;
  let googleGlobalLoaderDepth = 0;
  const recurrenceEndSelections = new Map();
  const localEventsCache = { start: null, end: null, items: [] };
  let localCacheDirty = true;
  let localCachePromise = null;
  let initialListLoaded = false;

  function buildEventsFetchUrl(startDate, endDate){
    const params = new URLSearchParams();
    if(startDate){
      params.append("start_date", startDate);
    }
    if(endDate){
      params.append("end_date", endDate);
    }
    const query = params.toString();
    return query ? `${apiBase}/events?${query}` : `${apiBase}/events`;
  }

  async function fetchLocalEventsBetween(startDate, endDate){
    const url = buildEventsFetchUrl(startDate, endDate);
    const res = await fetch(url);
    if(!res.ok){
      throw new Error("local events failed");
    }
    const data = await res.json();
    return Array.isArray(data) ? data : [];
  }

  function markLocalCacheDirty(){
    localCacheDirty = true;
  }

  function cacheCoversRange(cache, startDate, endDate){
    return !!cache.start && !!cache.end && startDate >= cache.start && endDate <= cache.end;
  }

  function filterEventsInRange(items, startDate, endDate){
    return (items || []).filter(ev => eventIntersectsRange(ev, startDate, endDate));
  }

  async function getLocalEventsForRange(startDate, endDate){
    if(!startDate || !endDate) return [];
    if(!localCacheDirty && cacheCoversRange(localEventsCache, startDate, endDate)){
      return filterEventsInRange(localEventsCache.items, startDate, endDate);
    }
    if(localCachePromise){
      try{
        await localCachePromise;
      }catch(err){
        // ignore, fallback to fetching below
      }
      if(!localCacheDirty && cacheCoversRange(localEventsCache, startDate, endDate)){
        return filterEventsInRange(localEventsCache.items, startDate, endDate);
      }
    }
    localCachePromise = (async () => {
      const data = await fetchLocalEventsBetween(startDate, endDate);
      localEventsCache.start = startDate;
      localEventsCache.end = endDate;
      localEventsCache.items = Array.isArray(data) ? data : [];
      localCacheDirty = false;
      return localEventsCache.items;
    })().catch((err) => {
      localCacheDirty = true;
      throw err;
    }).finally(() => {
      localCachePromise = null;
    });
    const data = await localCachePromise;
    return filterEventsInRange(data, startDate, endDate);
  }

  function validateDateRange(start, end){
    if(!start || !end){
      return { ok:false, message:"시작·종료 날짜를 모두 선택해주세요." };
    }
    const startMs = Date.parse(start);
    const endMs = Date.parse(end);
    if(Number.isNaN(startMs) || Number.isNaN(endMs)){
      return { ok:false, message:"날짜 형식이 잘못되었습니다." };
    }
    if(endMs < startMs){
      return { ok:false, message:"종료 날짜가 시작 날짜보다 빠릅니다." };
    }
    const diffDays = Math.floor((endMs - startMs) / MS_PER_DAY);
    if(diffDays > 365){
      return { ok:false, message:"범위는 최대 1년까지만 설정할 수 있습니다." };
    }
    return { ok:true };
  }

  function getDeleteScopeOrAlert(){
    const startInput = document.getElementById("delete-scope-start");
    const endInput = document.getElementById("delete-scope-end");
    const start = startInput?.value || "";
    const end = endInput?.value || "";
    const validation = validateDateRange(start, end);
    if(!validation.ok){
      alert(validation.message);
      return null;
    }
    return { start, end };
  }

  function setDefaultDateRange(startId, endId, spanDays){
    const startInput = document.getElementById(startId);
    const endInput = document.getElementById(endId);
    if(!startInput || !endInput) return;
    if(startInput.value && endInput.value) return;
    const startDate = new Date();
    const endDate = new Date(startDate.getTime() + spanDays * MS_PER_DAY);
    const fmt = (dt) => dt.toISOString().slice(0,10);
    if(!startInput.value){
      startInput.value = fmt(startDate);
    }
    if(!endInput.value){
      endInput.value = fmt(endDate);
    }
  }

  function toDateStrLocal(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }

  function getCalendarViewRange(info){
    const startSource = (info && info.start) ? info.start : new Date();
    const startDate = new Date(startSource);
    const endSource = (info && info.end) ? info.end : startDate;
    let endDate = new Date(endSource);
    endDate = new Date(endDate.getTime() - MS_PER_DAY);
    if(endDate < startDate){
      endDate = new Date(startDate);
    }
    const diffDays = Math.floor((endDate.getTime() - startDate.getTime()) / MS_PER_DAY);
    if(diffDays > 365){
      endDate = new Date(startDate.getTime() + 365 * MS_PER_DAY);
    }
    return {
      startDate,
      endDate,
      startStr: toDateStrLocal(startDate),
      endStr: toDateStrLocal(endDate)
    };
  }

  function updateYearMonthLabel(date){
    const ymLabel = document.getElementById("ym-label");
    const y = date.getFullYear();
    const m = date.getMonth() + 1;
    ymLabel.textContent = `${y}년 ${m}월`;
  }

  function setActiveView(viewType){
    document.querySelectorAll("[data-cal-view]").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.calView === viewType);
    });
  }

  function setSelectedDate(dateStr){
    selectedDateStr = dateStr;
    const el = document.getElementById("selected-date-label");
    if(el) el.textContent = dateStr;
    if(calendar){
      syncSelectedDayHighlight();
    }
  }

  function syncSelectedDayHighlight(){
    const target = selectedDateStr;
    if(!target){
      return;
    }
    requestAnimationFrame(() => {
      document.querySelectorAll("#calendar .fc-daygrid-day[data-date]").forEach(cell => {
        cell.classList.toggle("selected-day", cell.getAttribute("data-date") === target);
      });
      document.querySelectorAll("#calendar .fc-col-header-cell[data-date]").forEach(cell => {
        cell.classList.toggle("selected-day-header", cell.getAttribute("data-date") === target);
      });
      document.querySelectorAll("#calendar .fc-timegrid-col[data-date]").forEach(col => {
        col.classList.toggle("selected-day", col.getAttribute("data-date") === target);
      });
    });
  }

  function formatCreatedAt(ts){
    if(!ts) return "";
    try{
      const [d,t] = ts.split("T");
      const [y,m,da] = d.split("-").map(x => parseInt(x,10));
      const [hh,mm] = (t || "00:00").split(":").map(x => parseInt(x,10));
      const dt = new Date(Date.UTC(y, (m||1)-1, da||1, hh||0, mm||0));
      return new Intl.DateTimeFormat("ko-KR", {
        month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit",
        hour12:false, timeZone:"Asia/Seoul"
      }).format(dt);
    }catch{
      return ts;
    }
  }

  function setupShadowAutoGrow(textareaId){
    const ta = document.getElementById(textareaId);
    if(!ta) return;

    let base = 56;
    let rafId = null;

    const computeBase = () => {
      const prev = ta.value;
      ta.value = "";
      ta.style.height = "auto";
      const measured = ta.scrollHeight;
      base = Math.max(measured || 0, 56);
      ta.value = prev;
    };

    const resize = () => {
      const value = ta.value ?? "";
      if(value.trim() === ""){
        if(rafId) cancelAnimationFrame(rafId);
        ta.style.height = base + "px";
        return;
      }

      const startH = ta.getBoundingClientRect().height;
      ta.style.height = "auto";
      let target = ta.scrollHeight;

      if(target <= base + 1){ target = base; }
      ta.style.height = startH + "px";

      if(rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => { ta.style.height = target + "px"; });
    };

    requestAnimationFrame(() => {
      computeBase();
      ta.style.height = base + "px";
      resize();
    });

    ["input","focus","change"].forEach(evt => ta.addEventListener(evt, resize));
    window.addEventListener("resize", () => { computeBase(); resize(); });
  }

  function toDateOnly(value){
    if(!value || value.length < 10) return null;
    return value.slice(0,10);
  }

  function addDaysToDateStr(dateStr, days){
    if(!dateStr) return null;
    const parts = dateStr.split("-").map(part => parseInt(part, 10));
    if(parts.length !== 3 || parts.some(n => Number.isNaN(n))) return null;
    const [y, m, d] = parts;
    const dt = new Date(Date.UTC(y, m - 1, d));
    dt.setUTCDate(dt.getUTCDate() + days);
    const yy = dt.getUTCFullYear();
    const mm = String(dt.getUTCMonth() + 1).padStart(2,"0");
    const dd = String(dt.getUTCDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }

  function getEventDateSpan(ev){
    if(!ev) return null;
    const startDate = toDateOnly(ev.start) || toDateOnly(ev.end);
    if(!startDate) return null;
    let endDate = toDateOnly(ev.end) || startDate;
    if((ev.allDay === true || ev.all_day === true) && ev.end && typeof ev.end === "string" && ev.end.endsWith("T00:00")){
      const adjusted = addDaysToDateStr(endDate, -1);
      if(adjusted) endDate = adjusted;
    }
    if(endDate < startDate){
      endDate = startDate;
    }
    return { start: startDate, end: endDate };
  }

  function eventCoversDate(ev, dateStr){
    if(!ev || !dateStr) return false;
    const span = getEventDateSpan(ev);
    if(!span) return false;
    return dateStr >= span.start && dateStr <= span.end;
  }

  function eventIntersectsRange(ev, startDateStr, endDateStr){
    const span = getEventDateSpan(ev);
    if(!span || !startDateStr || !endDateStr) return false;
    if(span.end < startDateStr) return false;
    if(span.start > endDateStr) return false;
    return true;
  }

  function isAllDayRange(start, end){
    if(!start) return false;
    const startDate = toDateOnly(start);
    if(!startDate) return false;
    const startTime = start.length >= 16 ? start.slice(11,16) : "00:00";
    if(startTime !== "00:00") return false;
    if(!end){
      return true;
    }
    const endDate = toDateOnly(end);
    if(!endDate) return true;
    const endTime = end.length >= 16 ? end.slice(11,16) : "23:59";
    if(endDate < startDate) return false;
    if(endTime === "00:00"){
      return endDate > startDate;
    }
    return endTime === "23:59" || endTime === "00:00";
  }

  function fmtRange(start, end, allDayOverride){
    if(!start) return "";
    const startDate = toDateOnly(start);
    const isAllDay = (typeof allDayOverride === "boolean")
      ? allDayOverride
      : isAllDayRange(start, end);
    if(isAllDay){
      const endDate = toDateOnly(end);
      if(endDate && startDate && endDate !== startDate){
        return `${startDate}~${endDate} 하루종일`;
      }
      return `${startDate || ""} 하루종일`;
    }
    const st = start.slice(11,16);
    if(end) return `${startDate || ""} ${st}–${end.slice(11,16)}`;
    return `${startDate || ""} ${st}`;
  }

  function formatEventMeta(ev){
    if(!ev) return "";
    const startStr = ev.start || "";
    const endStr = ev.end || null;
    const isAllDay = (ev.all_day === true) || isAllDayRange(startStr, endStr);
    if(isAllDay){
      const startDate = toDateOnly(startStr);
      const endDate = toDateOnly(endStr);
      let label = "하루종일";
      if(startDate && endDate && startDate !== endDate){
        label = `하루종일 · ${startDate}~${endDate}`;
      }
      return ev.location ? `${label} · ${ev.location}` : label;
    }
    const timePart = startStr.length >= 16 ? startStr.slice(11,16) : "";
    const label = timePart ? `시작 ${timePart}` : "시간 없음";
    return ev.location ? `${label} · ${ev.location}` : label;
  }

  function closeEventModal(){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    overlay.classList.remove("active");
    overlay.style.display = "none";
    currentEventModalContext = null;
  }

  function openEventModal(eventInfo){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    const titleEl = document.getElementById("event-modal-title");
    const subEl = document.getElementById("event-modal-sub");
    const titleInput = document.getElementById("event-modal-input-title");
    const startDateInput = document.getElementById("event-modal-input-start-date");
    const startTimeInput = document.getElementById("event-modal-input-start-time");
    const endDateInput = document.getElementById("event-modal-input-end-date");
    const endTimeInput = document.getElementById("event-modal-input-end-time");
    const locationInput = document.getElementById("event-modal-input-location");
    const notesInput = document.getElementById("event-modal-input-notes");
    if(!titleInput || !startDateInput || !startTimeInput || !endDateInput || !endTimeInput || !locationInput || !notesInput){
      return;
    }

    const toLocalDate = (value) => {
      if(!value) return "";
      const dt = new Date(value);
      if(Number.isNaN(dt.getTime())){
        return (value || "").slice(0, 10);
      }
      const offset = dt.getTimezoneOffset();
      const adjusted = new Date(dt.getTime() - offset * 60 * 1000);
      return adjusted.toISOString().slice(0, 10);
    };

    const toLocalTime = (value) => {
      if(!value) return "";
      const dt = new Date(value);
      if(Number.isNaN(dt.getTime())) return "";
      return dt.toTimeString().slice(0, 5);
    };

    titleEl.textContent = eventInfo.title || "(제목 없음)";
    subEl.textContent = (eventInfo.source === "google") ? "Google 일정" : "내 일정";
    titleInput.value = eventInfo.title || "";
    startDateInput.value = toLocalDate(eventInfo.start);
    startTimeInput.value = eventInfo.allDay ? "" : toLocalTime(eventInfo.start);
    endDateInput.value = toLocalDate(eventInfo.end);
    endTimeInput.value = eventInfo.allDay ? "" : toLocalTime(eventInfo.end);
    locationInput.value = eventInfo.location || "";
    notesInput.value = eventInfo.notes || "";

    const numericId = parseInt(eventInfo.id, 10);
    currentEventModalContext = {
      source: eventInfo.source || "local",
      localId: (eventInfo.source === "google") ? null : (Number.isFinite(numericId) ? numericId : null),
      googleId: eventInfo.googleId || null
    };

    overlay.style.display = "flex";
    requestAnimationFrame(() => overlay.classList.add("active"));
  }

  async function saveEventModal(){
    if(!currentEventModalContext) return;
    const titleInput = document.getElementById("event-modal-input-title");
    const startDateInput = document.getElementById("event-modal-input-start-date");
    const startTimeInput = document.getElementById("event-modal-input-start-time");
    const endDateInput = document.getElementById("event-modal-input-end-date");
    const endTimeInput = document.getElementById("event-modal-input-end-time");
    const locationInput = document.getElementById("event-modal-input-location");
    const notesInput = document.getElementById("event-modal-input-notes");
    if(!titleInput || !startDateInput || !startTimeInput || !endDateInput || !endTimeInput || !locationInput || !notesInput){
      return;
    }

    const title = titleInput.value.trim();
    const startDate = startDateInput.value;
    const startTime = startTimeInput.value;
    const endDate = endDateInput.value;
    const endTime = endTimeInput.value;
    const locationValue = locationInput.value.trim();

    if(!title){
      alert("제목을 입력해주세요.");
      return;
    }
    if(!startDate){
      alert("시작 날짜를 입력해주세요.");
      return;
    }

    const combineDateTime = (dateVal, timeVal) => {
      if(!dateVal) return "";
      if(!timeVal) return `${dateVal}T00:00`;
      return `${dateVal}T${timeVal}`;
    };

    const payload = {
      title,
      start: combineDateTime(startDate, startTime),
      end: endDate ? combineDateTime(endDate, endTime || "00:00") : null,
      location: locationValue || null,
      all_day: !startTime && !endTime
    };

    if(payload.end){
      const startMs = Date.parse(payload.start);
      const endMs = Date.parse(payload.end);
      if(!Number.isNaN(startMs) && !Number.isNaN(endMs) && endMs < startMs){
        alert("종료 시각이 시작 시각보다 빠릅니다.");
        return;
      }
    }

    const headers = { "Content-Type": "application/json" };
    let touchedGoogleEvent = false;
    try{
      if(currentEventModalContext.source === "google"){
        const googleId = currentEventModalContext.googleId || "";
        if(googleId){
          await fetch(`/api/google/events/${encodeURIComponent(googleId)}`, {
            method:"PATCH",
            headers,
            body: JSON.stringify(payload)
          });
          touchedGoogleEvent = true;
        }
      }else{
        const localId = currentEventModalContext.localId;
        if(localId){
          await fetch(`/api/events/${localId}`, {
            method:"PATCH",
            headers,
            body: JSON.stringify(payload)
          });
          markLocalCacheDirty();
        }
      }
      if(touchedGoogleEvent){
        markGoogleCacheDirty();
      }
      closeEventModal();
      await refreshAll();
    }catch(err){
      console.error(err);
      alert("일정 수정에 실패했습니다.");
    }
  }

  async function deleteGoogleEventById(eventId){
    if(!eventId) return;
    const res = await fetch(apiBase + "/google/events/" + encodeURIComponent(eventId), {
      method:"DELETE"
    });
    if(res.ok){
      markGoogleCacheDirty();
    }
  }

  function updateUndoButton(){
    const btn = document.getElementById("undo-last-btn");
    if(!btn) return;
    const has = undoStack.length > 0;
    btn.disabled = !has;
    btn.textContent = has ? `되돌리기 (${undoStack.length})` : "되돌리기";
  }

  function recordUndoBatch(events){
    if(!Array.isArray(events) || events.length === 0) return;
    const batch = events
      .map(ev => ({
        localId: (typeof ev.id === "number" || /^\d+$/.test(String(ev.id || ""))) ? parseInt(ev.id, 10) : null,
        googleId: ev.google_event_id || null
      }))
      .filter(item => item.localId || item.googleId);
    if(!batch.length) return;
    undoStack.push(batch);
    updateUndoButton();
  }

  async function undoLastBatch(){
    if(undoStack.length === 0) return;
    const batch = undoStack.pop();
    updateUndoButton();
    const localIds = batch.map(item => item.localId).filter(id => Number.isFinite(id));
    const googleIds = batch.map(item => item.googleId).filter(id => !!id);
    try{
      if(localIds.length){
        await fetch(apiBase + "/delete-by-ids", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ ids: localIds })
        });
        markLocalCacheDirty();
      }
      for(const gid of googleIds){
        await deleteGoogleEventById(gid);
      }
      await refreshAll();
    }catch(err){
      console.error(err);
      alert("되돌리기에 실패했습니다.");
    }
  }

  async function loadEventListForDate(dateStr){
    const targetDate = dateStr || "";
    const ul = document.getElementById("events-ul");
    const countEl = document.getElementById("selected-count-label");
    ul.innerHTML = "";

    if(!targetDate){
      if(countEl) countEl.textContent = "없음";
      return;
    }

    let events = [];
    try{
      events = await getLocalEventsForRange(targetDate, targetDate);
    }catch(err){
      console.error(err);
      events = [];
    }

    const dayEvents = events
      .filter(ev => eventCoversDate(ev, targetDate))
      .map(ev => ({ ...ev, _source: "local" }));

    let googleDayEvents = [];
    if(IS_GOOGLE_MODE){
      try{
        await ensureGoogleEventsForDate(targetDate);
        googleDayEvents = collectGoogleEventsForDate(targetDate)
          .map(ev => ({ ...ev, _source: "google" }));
      }catch(err){
        console.error(err);
      }
    }

    const combined = [...dayEvents, ...googleDayEvents];

    combined.sort((a, b) => {
      const aStart = a.start || "";
      const bStart = b.start || "";
      if(aStart === bStart){
        return (a.title || "").localeCompare(b.title || "");
      }
      return aStart.localeCompare(bStart);
    });
    if(countEl) countEl.textContent = combined.length ? `${combined.length}개` : "없음";

    if(combined.length === 0){
      ul.innerHTML = "<li style='padding:10px 6px; color:var(--muted); font-weight:800;'>선택한 날짜에 일정이 없습니다.</li>";
      return;
    }

    for(const ev of combined){
      const li = document.createElement("li");
      li.addEventListener("click", () => {
        openEventModal({
          id: ev.id,
          title: ev.title,
          start: ev.start,
          end: ev.end,
          location: ev.location,
          notes: "",
          source: ev._source || "local",
          googleId: ev.google_event_id || ev.id,
          allDay: ev.all_day
        });
      });

      const dot = document.createElement("div");
      dot.className = "event-dot";

      const info = document.createElement("div");
      info.className = "event-info";

      const title = document.createElement("div");
      title.className = "event-title";
      title.textContent = ev.title || "";

      const meta = document.createElement("div");
      meta.className = "event-meta";
      meta.textContent = formatEventMeta(ev);

      info.appendChild(title);
      info.appendChild(meta);

      li.appendChild(dot);
      li.appendChild(info);
      const delBtn = document.createElement("button");
      delBtn.className = "delete-btn";
      delBtn.textContent = "삭제";
      delBtn.addEventListener("click", async (event) => {
        event.stopPropagation();
        if(ev._source === "google"){
          await deleteGoogleEventById(ev.google_event_id || "");
        }else{
          await fetch(apiBase + "/events/" + ev.id, { method:"DELETE" });
          markLocalCacheDirty();
        }
        await refreshAll();
      });
      li.appendChild(delBtn);
      ul.appendChild(li);
    }
  }

  // Recent added modal
  function closeRecentModal(){
    document.getElementById("recent-overlay").style.display = "none";
    const list = document.getElementById("recent-list");
    if(list) list.innerHTML = "";
  }

  async function loadRecentList(){
    const list = document.getElementById("recent-list");
    if(!list) return;
    list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>불러오는 중...</div>";
    try{
      const res = await fetch(apiBase + "/recent-events");
      if(!res.ok){
        list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>불러오기 실패</div>";
        return;
      }
      const data = await res.json();
      renderRecentList(Array.isArray(data) ? data : []);
    }catch(err){
      console.error(err);
      list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>불러오기 실패</div>";
    }
  }

  async function openRecentModal(){
    const overlay = document.getElementById("recent-overlay");
    if(!overlay) return;
    overlay.style.display = "flex";
    await loadRecentList();
  }

  function refreshRecentIfOpen(){
    const overlay = document.getElementById("recent-overlay");
    if(overlay && overlay.style.display === "flex"){
      loadRecentList();
    }
  }

  function renderRecentList(items){
    const list = document.getElementById("recent-list");
    if(!list) return;
    if(!items.length){
      list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>최근 14일 내 추가된 일정이 없습니다.</div>";
      return;
    }
    list.innerHTML = "";
    items.forEach((ev) => {
      const source = ev.source || "local";
      const row = document.createElement("div");
      row.className = "recent-item";

      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = (source === "google") ? "Google" : (ev.all_day ? "하루종일" : "일정");

      const main = document.createElement("div");
      main.className = "recent-main";

      const l1 = document.createElement("div");
      l1.className = "recent-line1";
      l1.textContent = ev.title || "(제목 없음)";

      const l2 = document.createElement("div");
      l2.className = "recent-line2";
      l2.textContent = fmtRange(ev.start, ev.end, ev.all_day) + (ev.location ? ` · ${ev.location}` : "");

      const meta = document.createElement("div");
      meta.className = "recent-meta";
      meta.textContent = `추가: ${formatCreatedAt(ev.created_at || ev.created || "")}`;

      main.appendChild(l1);
      main.appendChild(l2);
      main.appendChild(meta);

      const del = document.createElement("button");
      del.className = "recent-delete";
      del.type = "button";
      del.textContent = "삭제";
      del.addEventListener("click", async () => {
        if(!confirm("이 일정을 삭제할까요?")) return;
        try{
          if(source === "google"){
            await deleteGoogleEventById(ev.google_event_id || ev.id);
          }else{
            await fetch(apiBase + "/events/" + ev.id, { method:"DELETE" });
            markLocalCacheDirty();
          }
          await refreshAll();
          await loadRecentList();
        }catch(err){
          console.error(err);
          alert("삭제에 실패했습니다.");
        }
      });

      row.appendChild(badge);
      row.appendChild(main);
      row.appendChild(del);
      list.appendChild(row);
    });
  }

  async function refreshAll(){
    if(IS_GOOGLE_MODE && googleCacheDirty){
      clearGoogleEventCache();
      googleCacheDirty = false;
    }
    if(calendar) calendar.refetchEvents();
    if(selectedDateStr) await loadEventListForDate(selectedDateStr);
    refreshRecentIfOpen();
  }

  async function createEvent(e){
    e.preventDefault();

    const title = document.getElementById("title").value.trim();
    const start = document.getElementById("start").value;
    const end = document.getElementById("end").value;
    const location = document.getElementById("location").value.trim();

    if(!title || !start){
      alert("제목과 시작 시각은 필수입니다.");
      return;
    }

    const payload = { title, start, end: end || null, location: location || null };

    const res = await fetch(apiBase + "/events", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });

    if(res.ok){
      const created = await res.json();
      recordUndoBatch([created]);
      markLocalCacheDirty();
    }else{
      alert("일정 추가에 실패했습니다.");
      return;
    }

    document.getElementById("event-form").reset();
    await refreshAll();
  }

  function setUnifiedMode(isDelete){
    const btn = document.getElementById("nlp-action-btn");
    const loaderEl = document.querySelector("#nlp-unified-loader .loader");
    const scopeControls = document.getElementById("delete-scope-controls");
    if(!btn) return;

    btn.classList.toggle("mode-delete", isDelete);
    btn.classList.toggle("mode-add", !isDelete);

    if(loaderEl){
      loaderEl.classList.toggle("is-delete", isDelete);
    }
    if(scopeControls){
      scopeControls.style.display = isDelete ? "block" : "none";
    }
  }

  function setUnifiedBusy(isBusy){
    const btn = document.getElementById("nlp-action-btn");
    const loaderWrap = document.getElementById("nlp-unified-loader");
    if(!btn || !loaderWrap) return;

    btn.disabled = !!isBusy;
    btn.classList.toggle("scale-0", !!isBusy);
    btn.classList.toggle("scale-1", !isBusy);
    loaderWrap.classList.toggle("scale-1", !!isBusy);
    loaderWrap.classList.toggle("scale-0", !isBusy);
  }

  function setGlobalLoadingOverlayVisible(visible, message){
    const overlay = document.getElementById("global-loading-overlay");
    if(!overlay) return;
    if(message){
      const textEl = overlay.querySelector(".global-loading-text");
      if(textEl) textEl.textContent = message;
    }
    overlay.classList.toggle("active", !!visible);
    if(document && document.body){
      document.body.classList.toggle("global-loading-active", !!visible);
    }
  }

  function pushGlobalLoading(message){
    googleGlobalLoaderDepth += 1;
    setGlobalLoadingOverlayVisible(true, message || "불러오는 중..");
  }

  function popGlobalLoading(){
    googleGlobalLoaderDepth = Math.max(googleGlobalLoaderDepth - 1, 0);
    if(googleGlobalLoaderDepth === 0){
      setGlobalLoadingOverlayVisible(false);
    }
  }

  function markGoogleCacheDirty(){
    if(!IS_GOOGLE_MODE) return;
    googleCacheDirty = true;
  }

  function clearGoogleEventCache(){
    googleCacheGeneration += 1;
    Object.keys(googleEventCache).forEach((key) => delete googleEventCache[key]);
    Object.keys(googleEventFetches).forEach((key) => delete googleEventFetches[key]);
  }

  function normalizeGoogleEvent(ev){
    if(!ev) return null;
    let start = ev.start || "";
    const end = ev.end || null;
    if(!start && end){
      start = end;
    }
    if(!start) return null;
    const unique = ev.id || start || end || ev.html_link || `${Date.now()}-${Math.random()}`;
    return {
      id:`google:${unique}`,
      google_event_id: ev.id || "",
      title: ev.title || "(제목 없음)",
      start,
      end,
      location: ev.location || "",
      all_day: !!ev.all_day,
      source:"google"
    };
  }

  function getYearFromDateStr(value){
    if(!value || value.length < 4) return null;
    const num = parseInt(value.slice(0,4), 10);
    return Number.isFinite(num) ? num : null;
  }

  async function ensureGoogleEventsForYear(year){
    if(!IS_GOOGLE_MODE || !Number.isFinite(year)) return [];
    if(Array.isArray(googleEventCache[year])) return googleEventCache[year];
    if(googleEventFetches[year]) return googleEventFetches[year];

    const generationAtStart = googleCacheGeneration;
    const message = "불러오는 중..";
    const promise = (async () => {
      pushGlobalLoading(message);
      try{
        const params = new URLSearchParams({
          start_date: `${year}-01-01`,
          end_date: `${year}-12-31`
        });
        const res = await fetch(apiBase + "/google/events?" + params.toString());
        if(!res.ok){
          throw new Error("Google 일정 불러오기 실패");
        }
        const raw = await res.json();
        const normalized = (Array.isArray(raw) ? raw : []).map(normalizeGoogleEvent).filter(Boolean);
        if(generationAtStart === googleCacheGeneration){
          googleEventCache[year] = normalized;
        }
        return normalized;
      }finally{
        popGlobalLoading();
        delete googleEventFetches[year];
      }
    })().catch((err) => {
      console.error(err);
      throw err;
    });

    googleEventFetches[year] = promise;
    return promise;
  }

  async function ensureGoogleEventsForYears(years){
    if(!IS_GOOGLE_MODE) return;
    const uniqueYears = Array.from(new Set((years || []).filter((y) => Number.isFinite(y))));
    if(!uniqueYears.length) return;
    await Promise.all(uniqueYears.map((year) => ensureGoogleEventsForYear(year)));
  }

  async function ensureGoogleEventsForDate(dateStr){
    if(!IS_GOOGLE_MODE || !dateStr) return;
    const year = getYearFromDateStr(dateStr);
    if(Number.isFinite(year)){
      await ensureGoogleEventsForYear(year);
    }
  }

  function collectGoogleEventsForDate(dateStr){
    if(!IS_GOOGLE_MODE || !dateStr) return [];
    const results = [];
    Object.values(googleEventCache).forEach((bucket) => {
      if(!Array.isArray(bucket)) return;
      bucket.forEach((ev) => {
        if(eventCoversDate(ev, dateStr)){
          results.push(ev);
        }
      });
    });
    return results;
  }

  function collectGoogleEventsBetween(startDateStr, endDateStr){
    if(!IS_GOOGLE_MODE || !startDateStr || !endDateStr) return [];
    const results = [];
    Object.values(googleEventCache).forEach((bucket) => {
      if(!Array.isArray(bucket)) return;
      bucket.forEach((ev) => {
        if(eventIntersectsRange(ev, startDateStr, endDateStr)){
          results.push(ev);
        }
      });
    });
    return results;
  }

  // -------- Image attachment helpers --------
  function estimateDataUrlBytes(dataUrl){
    if(typeof dataUrl !== "string") return 0;
    const commaIdx = dataUrl.indexOf(",");
    const b64 = commaIdx >= 0 ? dataUrl.slice(commaIdx + 1) : dataUrl;
    return Math.ceil((b64.length * 3) / 4);
  }

  function clampDimensions(width, height, maxDim){
    if(width <= maxDim && height <= maxDim){
      return { width, height };
    }
    const scale = Math.min(maxDim / width, maxDim / height);
    return {
      width: Math.max(1, Math.round(width * scale)),
      height: Math.max(1, Math.round(height * scale))
    };
  }

  function readFileAsDataURL(file){
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function loadImageElement(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  async function compressImageFile(file){
    const base64 = await readFileAsDataURL(file);
    const img = await loadImageElement(base64);
    const { width, height } = clampDimensions(img.width, img.height, MAX_IMAGE_DIMENSION);
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, width, height);
    ctx.drawImage(img, 0, 0, width, height);

    let quality = 0.92;
    let dataUrl = canvas.toDataURL("image/jpeg", quality);
    let attempts = 0;
    while(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES && attempts < 5){
      quality = Math.max(0.5, quality - 0.1);
      dataUrl = canvas.toDataURL("image/jpeg", quality);
      attempts += 1;
    }
    if(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES){
      throw new Error("이미지 용량 초과");
    }
    return dataUrl;
  }

  async function handleImageFiles(fileList){
    if(!fileList) return;
    const files = Array.from(fileList);
    if(nlpImageAttachments.length >= MAX_IMAGE_ATTACHMENTS){
      alert(`이미지는 최대 ${MAX_IMAGE_ATTACHMENTS}장까지만 첨부할 수 있습니다.`);
      return;
    }
    for(const file of files){
      if(nlpImageAttachments.length >= MAX_IMAGE_ATTACHMENTS){
        alert(`이미지는 최대 ${MAX_IMAGE_ATTACHMENTS}장까지만 첨부할 수 있습니다.`);
        break;
      }
      if(!file.type.startsWith("image/")) continue;
      try{
        const dataUrl = await compressImageFile(file);
        nlpImageAttachments.push({
          id: imageAttachmentSeq++,
          name: file.name || `image-${imageAttachmentSeq}`,
          dataUrl
        });
      }catch(err){
        console.error(err);
        alert("이미지를 처리하지 못했습니다. 해상도를 줄이거나 다른 이미지를 사용해주세요.");
      }
    }
    renderNlpImageAttachments();
  }

  function renderNlpImageAttachments(){
    const host = document.getElementById("nlp-image-attachments");
    if(!host) return;
    host.innerHTML = "";
    nlpImageAttachments.forEach((att) => {
      const chip = document.createElement("div");
      chip.className = "image-chip";

      const img = document.createElement("img");
      img.src = att.dataUrl;
      img.alt = att.name || "attachment";
      chip.appendChild(img);

      const actions = document.createElement("div");
      actions.className = "image-chip-actions";

      const maskBtn = document.createElement("button");
      maskBtn.type = "button";
      maskBtn.textContent = "가리기";
      maskBtn.addEventListener("click", () => openImageEditor(att.id));
      actions.appendChild(maskBtn);

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "삭제";
      removeBtn.addEventListener("click", () => removeImageAttachment(att.id));
      actions.appendChild(removeBtn);

      chip.appendChild(actions);
      host.appendChild(chip);
    });
  }

  function removeImageAttachment(id){
    const idx = nlpImageAttachments.findIndex(att => att.id === id);
    if(idx >= 0){
      nlpImageAttachments.splice(idx, 1);
      renderNlpImageAttachments();
    }
  }

  function getNlpImagePayload(){
    return nlpImageAttachments.map(att => att.dataUrl);
  }

  function resetNlpComposerInputs(){
    const input = document.getElementById("nlp-unified-text");
    if(input){
      input.value = "";
      input.dispatchEvent(new Event("input"));
    }
    nlpImageAttachments.length = 0;
    renderNlpImageAttachments();
  }

  function resetRecurrenceEndSelections(){
    recurrenceEndSelections.clear();
  }

  function getRecurrenceEndSelection(idx){
    return recurrenceEndSelections.get(idx);
  }

  function setRecurrenceEndSelection(idx, payload){
    recurrenceEndSelections.set(idx, payload);
  }

  function buildRecurrenceEndControls(item, idx){
    const box = document.createElement("div");
    box.className = "rec-end-box";

    const title = document.createElement("h3");
    title.textContent = "반복 종료를 선택해주세요";
    box.appendChild(title);

    const options = document.createElement("div");
    options.className = "rec-end-options";
    const optionDefs = [
      { value:"none", label:"무기한" },
      { value:"until", label:"종료 날짜" },
      { value:"count", label:"횟수" }
    ];
    const name = `rec-end-${idx}`;

    const extra = document.createElement("div");
    extra.className = "rec-end-extra";

    const dateInput = document.createElement("input");
    dateInput.type = "date";
    dateInput.value = item.end_date || item.start_date || "";
    extra.appendChild(dateInput);

    const countInput = document.createElement("input");
    countInput.type = "number";
    countInput.min = "1";
    countInput.placeholder = "횟수";
    extra.appendChild(countInput);

    let currentMode = "none";

    const updateSelection = () => {
      if(currentMode === "until"){
        extra.style.display = "flex";
        dateInput.style.display = "";
        countInput.style.display = "none";
      }else if(currentMode === "count"){
        extra.style.display = "flex";
        dateInput.style.display = "none";
        countInput.style.display = "";
      }else{
        extra.style.display = "none";
        dateInput.style.display = "none";
        countInput.style.display = "none";
      }

      if(currentMode === "until"){
        setRecurrenceEndSelection(idx, {
          mode:"until",
          value: dateInput.value || null
        });
      }else if(currentMode === "count"){
        const numeric = countInput.value ? parseInt(countInput.value, 10) : null;
        setRecurrenceEndSelection(idx, {
          mode:"count",
          value: Number.isFinite(numeric) && numeric > 0 ? numeric : null
        });
      }else{
        setRecurrenceEndSelection(idx, { mode:"none", value:null });
      }
    };

    optionDefs.forEach(def => {
      const label = document.createElement("label");
      label.className = "rec-end-option";

      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = name;
      radio.value = def.value;
      if(def.value === "none"){
        radio.checked = true;
      }
      radio.addEventListener("change", () => {
        currentMode = def.value;
        updateSelection();
      });

      label.appendChild(radio);
      label.appendChild(document.createTextNode(def.label));
      options.appendChild(label);
    });

    dateInput.addEventListener("change", updateSelection);
    countInput.addEventListener("change", updateSelection);

    box.appendChild(options);
    box.appendChild(extra);
    currentMode = "none";
    updateSelection();
    return box;
  }

  function loadReasoningEffortFromStorage(){
    if(!IS_ADMIN) return;
    try{
      const stored = localStorage.getItem(REASONING_EFFORT_KEY);
      if(stored && ALLOWED_REASONING_EFFORTS.includes(stored)){
        reasoningEffortValue = stored;
      }
    }catch(_err){
      reasoningEffortValue = DEFAULT_REASONING_EFFORT;
    }
  }

  function saveReasoningEffortToStorage(value){
    if(!IS_ADMIN) return;
    try{
      localStorage.setItem(REASONING_EFFORT_KEY, value);
    }catch(_err){
      /* ignore */
    }
  }

  function initReasoningEffortControl(){
    const wrap = document.getElementById("reasoning-effort-control");
    const select = document.getElementById("reasoning-effort-select");
    if(!wrap || !select) return;
    if(!IS_ADMIN){
      wrap.style.display = "none";
      return;
    }
    loadReasoningEffortFromStorage();
    wrap.style.display = "flex";
    select.value = reasoningEffortValue;
    select.addEventListener("change", () => {
      const val = select.value;
      if(ALLOWED_REASONING_EFFORTS.includes(val)){
        reasoningEffortValue = val;
        saveReasoningEffortToStorage(val);
      }else{
        select.value = reasoningEffortValue;
      }
    });
  }

  function getReasoningEffortSetting(){
    if(!IS_ADMIN) return null;
    const select = document.getElementById("reasoning-effort-select");
    const candidate = select ? select.value : reasoningEffortValue;
    return ALLOWED_REASONING_EFFORTS.includes(candidate) ? candidate : null;
  }

  function openImageEditor(attachmentId){
    const target = nlpImageAttachments.find(att => att.id === attachmentId);
    if(!target || !imageEditorOverlay || !imageEditorCanvas || !imageEditorCtx){
      return;
    }
    imageEditorState.attachmentId = attachmentId;
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    setEditorCanvasFromDataUrl(target.dataUrl, true).then(() => {
      imageEditorOverlay.classList.add("active");
    }).catch(() => {
      alert("이미지 편집 도중 오류가 발생했습니다.");
      imageEditorState.attachmentId = null;
    });
  }

  function closeImageEditor(){
    if(imageEditorOverlay){
      imageEditorOverlay.classList.remove("active");
    }
    imageEditorState.attachmentId = null;
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    if(imageEditorSelectionCtx && imageEditorSelection){
      imageEditorSelectionCtx.clearRect(0, 0, imageEditorSelection.width, imageEditorSelection.height);
    }
  }

  function setEditorCanvasFromDataUrl(dataUrl, resetUndo){
    if(!imageEditorCanvas || !imageEditorCtx) return Promise.reject(new Error("canvas missing"));
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const { width, height } = clampDimensions(img.width, img.height, MAX_IMAGE_DIMENSION);
        imageEditorCanvas.width = width;
        imageEditorCanvas.height = height;
        if(imageEditorSelection){
          imageEditorSelection.width = width;
          imageEditorSelection.height = height;
        }
        imageEditorCtx.clearRect(0, 0, width, height);
        imageEditorCtx.drawImage(img, 0, 0, width, height);
        if(imageEditorSelectionCtx){
          imageEditorSelectionCtx.clearRect(0, 0, width, height);
        }
        if(resetUndo){
          imageEditorUndoStack = [imageEditorCanvas.toDataURL("image/png")];
        }
        resolve();
      };
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  function pushEditorSnapshot(){
    if(!imageEditorCanvas) return;
    const snapshot = imageEditorCanvas.toDataURL("image/png");
    imageEditorUndoStack.push(snapshot);
    if(imageEditorUndoStack.length > 10){
      imageEditorUndoStack.shift();
    }
  }

  function undoImageEditor(){
    if(imageEditorUndoStack.length <= 1) return;
    imageEditorUndoStack.pop();
    const previous = imageEditorUndoStack[imageEditorUndoStack.length - 1];
    setEditorCanvasFromDataUrl(previous, false);
  }

  function getEditorPointerPosition(evt){
    if(!imageEditorSelection) return { x: 0, y: 0 };
    const rect = imageEditorSelection.getBoundingClientRect();
    const scaleX = imageEditorSelection.width / rect.width;
    const scaleY = imageEditorSelection.height / rect.height;
    return {
      x: (evt.clientX - rect.left) * scaleX,
      y: (evt.clientY - rect.top) * scaleY
    };
  }

  function clearSelectionOverlay(){
    if(imageEditorSelectionCtx && imageEditorSelection){
      imageEditorSelectionCtx.clearRect(0, 0, imageEditorSelection.width, imageEditorSelection.height);
    }
  }

  function drawSelectionPreview(x1, y1, x2, y2){
    if(!imageEditorSelectionCtx) return;
    clearSelectionOverlay();
    const x = Math.min(x1, x2);
    const y = Math.min(y1, y2);
    const w = Math.abs(x2 - x1);
    const h = Math.abs(y2 - y1);
    if(w < 4 || h < 4) return;
    imageEditorSelectionCtx.fillStyle = "rgba(0,0,0,0.35)";
    imageEditorSelectionCtx.fillRect(x, y, w, h);
    imageEditorSelectionCtx.strokeStyle = "rgba(0,0,0,0.8)";
    imageEditorSelectionCtx.lineWidth = 2;
    imageEditorSelectionCtx.strokeRect(x + 1, y + 1, Math.max(0, w - 2), Math.max(0, h - 2));
  }

  function commitBlackout(x1, y1, x2, y2){
    if(!imageEditorCanvas || !imageEditorCtx) return;
    const w = Math.abs(x2 - x1);
    const h = Math.abs(y2 - y1);
    if(w < 4 || h < 4) return;
    const x = Math.max(0, Math.min(x1, x2));
    const y = Math.max(0, Math.min(y1, y2));
    imageEditorCtx.fillStyle = "#000000";
    imageEditorCtx.globalAlpha = 1;
    imageEditorCtx.fillRect(x, y, w, h);
    pushEditorSnapshot();
  }

  function imageEditorPointerDown(evt){
    if(!imageEditorSelection) return;
    evt.preventDefault();
    const { x, y } = getEditorPointerPosition(evt);
    imageEditorState.drawing = true;
    imageEditorState.pointerId = evt.pointerId;
    imageEditorState.startX = x;
    imageEditorState.startY = y;
    imageEditorSelection.setPointerCapture?.(evt.pointerId);
  }

  function imageEditorPointerMove(evt){
    if(!imageEditorState.drawing || imageEditorState.pointerId !== evt.pointerId) return;
    evt.preventDefault();
    const { x, y } = getEditorPointerPosition(evt);
    drawSelectionPreview(imageEditorState.startX, imageEditorState.startY, x, y);
  }

  function imageEditorPointerUp(evt){
    if(!imageEditorState.drawing || imageEditorState.pointerId !== evt.pointerId) return;
    evt.preventDefault();
    const { x, y } = getEditorPointerPosition(evt);
    commitBlackout(imageEditorState.startX, imageEditorState.startY, x, y);
    clearSelectionOverlay();
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    imageEditorSelection?.releasePointerCapture?.(evt.pointerId);
  }

  function imageEditorPointerCancel(evt){
    if(imageEditorState.pointerId !== evt.pointerId) return;
    clearSelectionOverlay();
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    imageEditorSelection?.releasePointerCapture?.(evt.pointerId);
  }

  function applyImageEditorEdits(){
    if(imageEditorState.attachmentId == null || !imageEditorCanvas){
      closeImageEditor();
      return;
    }
    let quality = 0.9;
    let dataUrl = imageEditorCanvas.toDataURL("image/jpeg", quality);
    let attempts = 0;
    while(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES && attempts < 4){
      quality = Math.max(0.5, quality - 0.1);
      dataUrl = imageEditorCanvas.toDataURL("image/jpeg", quality);
      attempts += 1;
    }
    if(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES){
      alert("편집 결과 이미지가 너무 큽니다. 가린 영역을 줄이거나 이미지를 축소해주세요.");
      return;
    }
    const target = nlpImageAttachments.find(att => att.id === imageEditorState.attachmentId);
    if(target){
      target.dataUrl = dataUrl;
      renderNlpImageAttachments();
    }
    closeImageEditor();
  }

  function setupImageComposer(){
    const attachBtn = document.getElementById("nlp-attach-btn");
    const fileInput = document.getElementById("nlp-image-input");
    imageEditorOverlay = document.getElementById("image-editor-overlay");
    imageEditorCanvas = document.getElementById("image-editor-canvas");
    imageEditorCtx = imageEditorCanvas?.getContext("2d") || null;
    imageEditorSelection = document.getElementById("image-editor-selection");
    imageEditorSelectionCtx = imageEditorSelection?.getContext("2d") || null;

    attachBtn?.addEventListener("click", () => fileInput?.click());
    fileInput?.addEventListener("change", async (event) => {
      await handleImageFiles(event.target.files);
      event.target.value = "";
    });

    document.getElementById("image-editor-cancel")?.addEventListener("click", closeImageEditor);
    document.getElementById("image-editor-apply")?.addEventListener("click", applyImageEditorEdits);
    document.getElementById("image-editor-undo")?.addEventListener("click", undoImageEditor);
    imageEditorOverlay?.addEventListener("click", (event) => {
      if(event.target === imageEditorOverlay){
        closeImageEditor();
      }
    });

    imageEditorSelection?.addEventListener("pointerdown", imageEditorPointerDown, { passive: false });
    imageEditorSelection?.addEventListener("pointermove", imageEditorPointerMove, { passive: false });
    imageEditorSelection?.addEventListener("pointerup", imageEditorPointerUp, { passive: false });
    imageEditorSelection?.addEventListener("pointercancel", imageEditorPointerCancel, { passive: false });
    imageEditorSelection?.addEventListener("pointerleave", imageEditorPointerCancel, { passive: false });

    renderNlpImageAttachments();
  }

  function setupEventModalControls(){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    document.getElementById("event-modal-close")?.addEventListener("click", closeEventModal);
    document.getElementById("event-modal-cancel")?.addEventListener("click", closeEventModal);
    document.getElementById("event-modal-save")?.addEventListener("click", saveEventModal);
    overlay.addEventListener("click", (event) => {
      if(event.target === overlay){
        closeEventModal();
      }
    });
  }

  // -------- Confirm Modal helpers --------
  function openConfirm(){ document.getElementById("confirm-overlay").style.display = "flex"; }
  function closeConfirm(){
    document.getElementById("confirm-overlay").style.display = "none";
    document.getElementById("confirm-list").innerHTML = "";
    confirmState = { mode: null, addItems: [], deleteGroups: [] };
    resetRecurrenceEndSelections();
  }

  async function openAddConfirm(text, imagePayload = []){
    const payload = { text };
    if(Array.isArray(imagePayload) && imagePayload.length){
      payload.images = imagePayload;
    }
    const effort = getReasoningEffortSetting();
    if(effort){
      payload.reasoning_effort = effort;
    }
    const res = await fetch(apiBase + "/nlp-preview", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      alert("추가할 일정을 해석하지 못했습니다.");
      return;
    }
    const data = await res.json();
    const items = Array.isArray(data?.items) ? data.items : [];
    if(items.length === 0){
      alert("추가할 일정을 찾지 못했습니다.");
      return;
    }

    confirmState.mode = "add";
    confirmState.addItems = items;
    resetRecurrenceEndSelections();

    document.getElementById("confirm-title").textContent = "이 일정을 추가할까요?";
    document.getElementById("confirm-desc").textContent = "체크한 항목만 추가됩니다. 반복 일정은 묶어서 선택하거나 상세에서 일부만 고를 수 있습니다.";

    const host = document.getElementById("confirm-list");
    host.innerHTML = "";

    const createEditableLabel = (initial, placeholder, onCommit) => {
      let currentValue = initial || "";
      const wrapper = document.createElement("div");
      wrapper.className = "cm-editable";
      let label = document.createElement("span");
      label.textContent = currentValue || placeholder;
      const iconBtn = document.createElement("button");
      iconBtn.type = "button";
      iconBtn.className = "cm-edit-icon";
      iconBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zm2.92.83h-.67v-.67l8.5-8.5.67.67-8.5 8.5zM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;

      const applyLabel = (value) => {
        currentValue = value || "";
        if(label) label.textContent = currentValue || placeholder;
      };

      const enterEdit = () => {
        if(wrapper.classList.contains("editing")) return;
        wrapper.classList.add("editing");
        const input = document.createElement("input");
        input.type = "text";
        input.value = currentValue || "";
        wrapper.insertBefore(input, iconBtn);
        if(label) label.remove();
        iconBtn.style.visibility = "hidden";
        input.focus();

        const finish = (apply) => {
          if(apply){
            const nextValue = input.value.trim();
            currentValue = nextValue;
            onCommit(nextValue);
          }
          input.remove();
          label = document.createElement("span");
          label.textContent = currentValue || placeholder;
          wrapper.insertBefore(label, iconBtn);
          iconBtn.style.visibility = "";
          wrapper.classList.remove("editing");
        };

        input.addEventListener("blur", () => finish(true));
        input.addEventListener("keydown", (e) => {
          if(e.key === "Enter"){
            e.preventDefault();
            finish(true);
          }else if(e.key === "Escape"){
            e.preventDefault();
            finish(false);
          }
        });
      };

      wrapper.appendChild(label);
      wrapper.appendChild(iconBtn);
      wrapper.addEventListener("click", enterEdit);
      iconBtn.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        enterEdit();
      });

      return {
        wrapper,
        updateLabel: applyLabel
      };
    };

    items.forEach((it, idx) => {
      const row = document.createElement("div");
      row.className = "cm-row";

      const top = document.createElement("div");
      top.className = "cm-row-top";

      const left = document.createElement("div");
      left.className = "cm-left";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = true;
      cb.className = "cm-check";
      cb.dataset.addIndex = String(idx);
      cb.dataset.role = "add-top";

      const main = document.createElement("div");
      main.className = "cm-main";

      const line1 = document.createElement("div");
      line1.className = "cm-line1";

      const line2 = document.createElement("div");
      line2.className = "cm-line2";

      const locationLine = document.createElement("div");
      locationLine.className = "cm-line-location";

      if(it.type === "single"){
        const titleEditable = createEditableLabel(it.title || "", "(제목 없음)", (val) => {
          it.title = val || "";
          updateSingleMeta();
        });
        const locationEditable = createEditableLabel(it.location || "", "(장소 없음)", (val) => {
          it.location = (val && val.trim()) || null;
          updateSingleMeta();
        });

        const updateSingleMeta = () => {
          titleEditable.updateLabel(it.title || "");
          locationEditable.updateLabel(it.location || "");
          line2.textContent = fmtRange(it.start, it.end, it.all_day);
        };
        updateSingleMeta();

        line1.appendChild(titleEditable.wrapper);
        locationLine.appendChild(locationEditable.wrapper);
        main.appendChild(line1);
        main.appendChild(locationLine);
        main.appendChild(line2);
        left.appendChild(cb);
        left.appendChild(main);
        top.appendChild(left);
        row.appendChild(top);
        host.appendChild(row);
        return;
      }

      const sd = it.start_date || "?";
      const ed = it.end_date || "?";
      const cnt = (typeof it.count === "number") ? it.count : 0;
      const time = it.time ? it.time : "시간 없음";

      const recurTitleEditable = createEditableLabel(it.title || "", "(제목 없음)", (val) => {
        it.title = val || "";
        updateRecurringMeta();
      });
      const recurLocationEditable = createEditableLabel(it.location || "", "(장소 없음)", (val) => {
        it.location = (val && val.trim()) || null;
        updateRecurringMeta();
      });

      const updateRecurringMeta = () => {
        recurTitleEditable.updateLabel(it.title || "");
        recurLocationEditable.updateLabel(it.location || "");
        line2.textContent = `반복: ${sd}~${ed} · ${time} · ${cnt}회`;
      };
      updateRecurringMeta();

      line1.appendChild(recurTitleEditable.wrapper);
      locationLine.appendChild(recurLocationEditable.wrapper);

      main.appendChild(line1);
      main.appendChild(locationLine);
      main.appendChild(line2);

      if(Array.isArray(it.samples) && it.samples.length){
        const mini = document.createElement("div");
        mini.className = "cm-mini";
        const s = it.samples.slice(0,3).map(x => (x || "").replace("T"," ")).join(" / ");
        mini.textContent = `예: ${s}${(cnt > 3) ? " …" : ""}`;
        main.appendChild(mini);
      }

      left.appendChild(cb);
      left.appendChild(main);

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "cm-toggle";
      toggle.textContent = "상세";

      const sub = document.createElement("div");
      sub.className = "cm-sublist";

      const occ = Array.isArray(it.occurrences) ? it.occurrences : [];
      occ.forEach((occurrence, occIdx) => {
        const subItem = document.createElement("div");
        subItem.className = "cm-subitem";

        const occCb = document.createElement("input");
        occCb.type = "checkbox";
        occCb.checked = true;
        occCb.dataset.role = "add-occurrence";
        occCb.dataset.addIndex = String(idx);
        occCb.dataset.addOccurrenceIndex = String(occIdx);

        const info = document.createElement("div");
        info.style.minWidth = "0";

        const oLine1 = document.createElement("div");
        oLine1.className = "cm-line1";
        oLine1.textContent = occurrence.title || it.title || "";

        const oLine2 = document.createElement("div");
        oLine2.className = "cm-line2";
        oLine2.textContent = fmtRange(occurrence.start, occurrence.end, occurrence.all_day) + (occurrence.location ? ` · ${occurrence.location}` : "");

        info.appendChild(oLine1);
        info.appendChild(oLine2);

        subItem.appendChild(occCb);
        subItem.appendChild(info);
        sub.appendChild(subItem);
      });

      cb.addEventListener("change", () => {
        cb.indeterminate = false;
        sub.querySelectorAll("input[type=checkbox][data-role='add-occurrence']").forEach(x => {
          x.checked = cb.checked;
        });
      });

      sub.addEventListener("change", () => {
        const cbs = Array.from(sub.querySelectorAll("input[type=checkbox][data-role='add-occurrence']"));
        const all = cbs.every(x => x.checked);
        const any = cbs.some(x => x.checked);
        cb.checked = any;
        cb.indeterminate = any && !all;
      });

      toggle.addEventListener("click", () => {
        const open = sub.style.display === "block";
        sub.style.display = open ? "none" : "block";
        toggle.textContent = open ? "상세" : "접기";
      });

      top.appendChild(left);
      top.appendChild(toggle);
      row.appendChild(top);
      row.appendChild(sub);
      if(it.requires_end_confirmation){
        const endControls = buildRecurrenceEndControls(it, idx);
        row.appendChild(endControls);
      }
      host.appendChild(row);
    });

    openConfirm();
  }

  async function openDeleteConfirm(text, scope){
    if(!scope) return;
    const payload = { text, start_date: scope.start, end_date: scope.end };
    const effort = getReasoningEffortSetting();
    if(effort){
      payload.reasoning_effort = effort;
    }
    const res = await fetch(apiBase + "/nlp-delete-preview", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      alert("삭제할 일정을 찾지 못했습니다.");
      return;
    }
    const data = await res.json();
    const groups = Array.isArray(data?.groups) ? data.groups : [];
    if(groups.length === 0){
      alert("삭제할 일정을 찾지 못했습니다.");
      return;
    }

    confirmState.mode = "delete";
    confirmState.deleteGroups = groups;

    document.getElementById("confirm-title").textContent = "이 일정을 삭제할까요?";
    document.getElementById("confirm-desc").textContent = "체크한 항목만 삭제됩니다. 반복 일정은 묶어서 선택할 수 있습니다.";

    const host = document.getElementById("confirm-list");
    host.innerHTML = "";

    groups.forEach((g, gi) => {
      const row = document.createElement("div");
      row.className = "cm-row";

      const top = document.createElement("div");
      top.className = "cm-row-top";

      const left = document.createElement("div");
      left.className = "cm-left";

      const gcb = document.createElement("input");
      gcb.type = "checkbox";
      gcb.checked = true;
      gcb.className = "cm-check";
      gcb.dataset.groupIndex = String(gi);

      const main = document.createElement("div");
      main.className = "cm-main";

      const line1 = document.createElement("div");
      line1.className = "cm-line1";
      const kindLabel = (g.kind === "recurring") ? "반복" : "단일";
      line1.textContent = `${kindLabel} · ${g.title || ""}`;

      const line2 = document.createElement("div");
      line2.className = "cm-line2";
      const time = g.time ? g.time : "";
      const loc = g.location ? g.location : "";
      const cnt = (typeof g.count === "number") ? g.count : (Array.isArray(g.ids) ? g.ids.length : 0);
      line2.textContent = `${time}${time && loc ? " · " : ""}${loc}${(time || loc) ? " · " : ""}${cnt}개`;

      main.appendChild(line1);
      main.appendChild(line2);

      left.appendChild(gcb);
      left.appendChild(main);

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "cm-toggle";
      toggle.textContent = "상세";

      const sub = document.createElement("div");
      sub.className = "cm-sublist";

      const items = Array.isArray(g.items) ? g.items : [];
      items.forEach((it) => {
        const si = document.createElement("div");
        si.className = "cm-subitem";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = true;
        cb.dataset.deleteId = String(it.id);

        const meta = document.createElement("div");
        meta.style.minWidth = "0";

        const l1 = document.createElement("div");
        l1.className = "cm-line1";
        l1.textContent = it.title || "";

        const l2 = document.createElement("div");
        l2.className = "cm-line2";
        l2.textContent = fmtRange(it.start, it.end, it.all_day) + (it.location ? ` · ${it.location}` : "");

        meta.appendChild(l1);
        meta.appendChild(l2);

        si.appendChild(cb);
        si.appendChild(meta);
        sub.appendChild(si);
      });

      gcb.addEventListener("change", () => {
        sub.querySelectorAll("input[type=checkbox][data-delete-id]").forEach(x => {
          x.checked = gcb.checked;
          x.indeterminate = false;
        });
      });

      sub.addEventListener("change", () => {
        const cbs = Array.from(sub.querySelectorAll("input[type=checkbox][data-delete-id]"));
        const all = cbs.every(x => x.checked);
        const any = cbs.some(x => x.checked);
        gcb.checked = any;
        gcb.indeterminate = any && !all;
      });

      toggle.addEventListener("click", () => {
        const open = sub.style.display === "block";
        sub.style.display = open ? "none" : "block";
        toggle.textContent = open ? "상세" : "접기";
      });

      top.appendChild(left);
      top.appendChild(toggle);

      row.appendChild(top);
      row.appendChild(sub);
      host.appendChild(row);
    });

    openConfirm();
  }

  // ✅ 실행 버튼/Enter: 바로 추가/삭제 X → 확인 모달 오픈
  async function runUnifiedNlpAction(){
    const input = document.getElementById("nlp-unified-text");
    const toggle = document.getElementById("nlp-mode-toggle");
    const text = input?.value?.trim() ?? "";
    const imagePayload = getNlpImagePayload();

    const isDelete = !!toggle?.checked;
    if(isDelete){
      if(!text){
        alert("삭제할 문장을 입력해주세요.");
        return;
      }
    }else if(!text && imagePayload.length === 0){
      alert("문장이나 이미지를 입력해주세요.");
      return;
    }

    setUnifiedBusy(true);
    try{
      if(isDelete){
        const scope = getDeleteScopeOrAlert();
        if(!scope) return;
        await openDeleteConfirm(text, scope);
      }else{
        await openAddConfirm(text, imagePayload);
      }
    }catch(err){
      console.error(err);
      alert("실행 중 오류가 발생했습니다. 다시 시도해주세요.");
    }finally{
      setUnifiedBusy(false);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // Calendar init
    const calendarEl = document.getElementById("calendar");
    selectedDateStr = toDateStrLocal(new Date());
    setSelectedDate(selectedDateStr);

    calendar = new FullCalendar.Calendar(calendarEl, {
      initialView:"dayGridMonth",
      locale:"ko",
      height:"auto",
      headerToolbar:false,
      fixedWeekCount:false,
      dayMaxEventRows:4,

      dayCellClassNames: (arg) => {
        const ds = toDateStrLocal(arg.date);
        return (ds === selectedDateStr) ? ["selected-day"] : [];
      },
      dayHeaderClassNames: (arg) => {
        const ds = toDateStrLocal(arg.date);
        return (ds === selectedDateStr) ? ["selected-day-header"] : [];
      },

      events: async (info, success, failure) => {
        const formatLocalEvent = (ev) => {
          const rawStart = ev.start || "";
          const rawEnd = ev.end || null;
          const allDay = (ev.all_day === true) || isAllDayRange(rawStart, rawEnd);
          if(allDay){
            const startDateOnly = toDateOnly(rawStart) || toDateOnly(rawEnd) || "";
            const inclusiveEnd = toDateOnly(rawEnd) || startDateOnly;
            const exclusiveEnd = addDaysToDateStr(inclusiveEnd, 1) || addDaysToDateStr(startDateOnly, 1);
            const startValue = startDateOnly || toDateStrLocal(new Date());
            return {
              id:String(ev.id),
              title:ev.title,
              start:startValue,
              end:exclusiveEnd,
              allDay:true,
              extendedProps:{location: ev.location || "", allDay:true, source:"local"}
            };
          }
          return {
            id:String(ev.id),
            title:ev.title,
            start:rawStart,
            end:rawEnd || null,
            allDay:false,
            extendedProps:{location: ev.location || "", allDay:false, source:"local"}
          };
        };

        const formatGoogleEvent = (ev) => {
          const rawStart = ev.start || "";
          const rawEnd = ev.end || null;
          const allDay = !!ev.all_day;
          if(allDay){
            const startDateOnly = toDateOnly(rawStart) || toDateOnly(rawEnd) || "";
            const inclusiveEnd = toDateOnly(rawEnd) || startDateOnly;
            const exclusiveEnd = addDaysToDateStr(inclusiveEnd, 1) || addDaysToDateStr(startDateOnly, 1);
            return {
              id:ev.id,
              title: ev.title || "(제목 없음)",
              start:startDateOnly || rawStart,
              end:exclusiveEnd,
              allDay:true,
              extendedProps:{
                location: ev.location || "",
                allDay:true,
                source:"google",
                googleId: ev.google_event_id || ""
              }
            };
          }
          return {
            id:ev.id,
            title: ev.title || "(제목 없음)",
            start:rawStart,
            end:rawEnd || null,
            allDay:false,
            extendedProps:{
              location: ev.location || "",
              allDay:false,
              source:"google",
              googleId: ev.google_event_id || ""
            }
          };
        };

        try{
          const showLocal = !IS_GOOGLE_MODE;
          const showGoogle = IS_GOOGLE_MODE;
          const viewRange = getCalendarViewRange(info);
          const viewStartDate = viewRange.startDate;
          const viewEndDate = viewRange.endDate;
          const viewStartStr = viewRange.startStr;
          const viewEndStr = viewRange.endStr;

          let localEvents = [];
          if(showLocal){
            const data = await getLocalEventsForRange(viewStartStr, viewEndStr);
            localEvents = Array.isArray(data) ? data.map(formatLocalEvent) : [];
          }

          let googleEvents = [];
          if(showGoogle){
            const years = [];
            const startYear = viewStartDate.getFullYear();
            const endYear = viewEndDate.getFullYear();
            for(let y = startYear; y <= endYear; y += 1){
              years.push(y);
            }
            await ensureGoogleEventsForYears(years);
            const cachedRange = collectGoogleEventsBetween(viewStartStr, viewEndStr);
            googleEvents = cachedRange.map(formatGoogleEvent);
          }

          success([...(localEvents || []), ...(googleEvents || [])]);
        }catch(err){
          console.error(err);
          failure(err);
        }
      },

      dateClick: (info) => {
        setSelectedDate(info.dateStr);
        loadEventListForDate(selectedDateStr);
      },

      eventClick: (info) => {
        const ev = info.event;
        openEventModal({
          id: ev.id,
          title: ev.title,
          start: ev.start ? ev.start.toISOString() : "",
          end: ev.end ? ev.end.toISOString() : "",
          location: ev.extendedProps.location,
          notes: "",
          source: ev.extendedProps.source || "local",
          googleId: ev.extendedProps.googleId || null,
          allDay: ev.allDay
        });
      },

      datesSet: (info) => {
        updateYearMonthLabel(info.view.calendar.getDate());
        setActiveView(info.view.type);
        syncSelectedDayHighlight();
      },

      loading: (isLoading) => {
        if(!isLoading && !initialListLoaded){
          initialListLoaded = true;
          if(selectedDateStr){
            loadEventListForDate(selectedDateStr);
          }
        }
      }
    });

    calendar.render();
    syncSelectedDayHighlight();
    updateYearMonthLabel(calendar.getDate());
    setActiveView(calendar.view.type);

    // topbar controls
    document.getElementById("cal-prev").addEventListener("click", () => calendar.prev());
    document.getElementById("cal-next").addEventListener("click", () => calendar.next());
    document.getElementById("cal-today").addEventListener("click", () => {
      calendar.today();
      const d = toDateStrLocal(new Date());
      setSelectedDate(d);
      loadEventListForDate(d);
    });

    document.querySelectorAll("[data-cal-view]").forEach(btn => {
      btn.addEventListener("click", () => {
        const view = btn.dataset.calView;
        calendar.changeView(view);
        setActiveView(view);
      });
    });

    // quick add
    // NLP auto-grow
    setupShadowAutoGrow("nlp-unified-text");
    setupImageComposer();
    initReasoningEffortControl();
    setupEventModalControls();

    const toggle = document.getElementById("nlp-mode-toggle");
    const actionBtn = document.getElementById("nlp-action-btn");

    setUnifiedMode(toggle.checked);
    toggle.addEventListener("change", () => setUnifiedMode(toggle.checked));
    actionBtn.addEventListener("click", runUnifiedNlpAction);

    setDefaultDateRange("delete-scope-start", "delete-scope-end", 30);
    updateUndoButton();
    const undoBtn = document.getElementById("undo-last-btn");
    if(undoBtn){
      undoBtn.addEventListener("click", undoLastBatch);
    }

    const recentBtn = document.getElementById("recent-added-btn");
    if(recentBtn){
      recentBtn.style.display = "";
      recentBtn.addEventListener("click", openRecentModal);
    }

    const ta = document.getElementById("nlp-unified-text");
    if(ta){
      ta.addEventListener("compositionstart", () => { nlpInputComposing = true; });
      ta.addEventListener("compositionend", () => { nlpInputComposing = false; });
      ta.addEventListener("blur", () => { nlpInputComposing = false; });

      ta.addEventListener("keydown", (e) => {
        if(e.key === "Enter" && !e.shiftKey){
          if(e.isComposing || nlpInputComposing) return;
          e.preventDefault();
          runUnifiedNlpAction();
        }
      });
    }

    // pill placeholders
    function setupPillPlaceholder(inputId){
      const input = document.getElementById(inputId);
      const wrap = input?.closest(".pill-field");
      const ph = wrap?.querySelector(".pill-placeholder");
      if(!input || !ph) return;

      const update = () => {
        if(input.value && input.value.trim() !== ""){
          ph.classList.add("hidden");
          input.classList.add("has-value");
        }else{
          ph.classList.remove("hidden");
          input.classList.remove("has-value");
        }
      };
      input.addEventListener("input", update);
      input.addEventListener("change", update);
      update();
    }
    setupPillPlaceholder("start");
    setupPillPlaceholder("end");
    setupPillPlaceholder("location");

    // confirm modal bindings
    document.getElementById("confirm-close").addEventListener("click", closeConfirm);
    document.getElementById("confirm-cancel").addEventListener("click", closeConfirm);
    document.getElementById("confirm-overlay").addEventListener("click", (e) => {
      if(e.target && e.target.id === "confirm-overlay") closeConfirm();
    });

    document.getElementById("recent-close").addEventListener("click", closeRecentModal);
    document.getElementById("recent-cancel").addEventListener("click", closeRecentModal);
    document.getElementById("recent-overlay").addEventListener("click", (e) => {
      if(e.target && e.target.id === "recent-overlay") closeRecentModal();
    });

    document.getElementById("confirm-ok").addEventListener("click", async () => {
      if(confirmState.mode === "add"){
        const topChecks = Array.from(document.querySelectorAll("input[type=checkbox][data-role='add-top']"));
        const chosenIdx = topChecks
          .filter(x => x.checked)
          .map(x => parseInt(x.dataset.addIndex, 10))
          .filter(n => Number.isFinite(n));

        const occSelected = {};
        document.querySelectorAll("input[type=checkbox][data-role='add-occurrence']").forEach(el => {
          const addIdx = parseInt(el.dataset.addIndex || "", 10);
          const occIdx = parseInt(el.dataset.addOccurrenceIndex || "", 10);
          if(!Number.isFinite(addIdx) || !Number.isFinite(occIdx)) return;
          if(!occSelected[addIdx]) occSelected[addIdx] = [];
          if(el.checked){
            occSelected[addIdx].push(occIdx);
          }
        });

        const selectedEntries = [];
        chosenIdx.forEach(idx => {
          const base = confirmState.addItems[idx];
          if(!base) return;

          if((base.type || "").toLowerCase() === "recurring"){
            const occList = occSelected[idx];
            if(Array.isArray(occList) && occList.length > 0){
              selectedEntries.push({ idx, item: { ...base, selected_occurrence_indexes: occList } });
              return;
            }
            if(occSelected[idx] === undefined){
              selectedEntries.push({ idx, item: base });
              return;
            }
            return;
          }
          selectedEntries.push({ idx, item: base });
        });

        const selected = selectedEntries.map(entry => entry.item);

        if(selected.length === 0){
          alert("추가할 항목을 선택해주세요.");
          return;
        }

        for(const entry of selectedEntries){
          const original = confirmState.addItems[entry.idx];
          if(original && original.requires_end_confirmation){
            const selection = getRecurrenceEndSelection(entry.idx);
            if(!selection){
              alert("반복 종료 방식을 선택해주세요.");
              return;
            }
            if(selection.mode === "until" && !selection.value){
              alert("반복 종료 날짜를 입력해주세요.");
              return;
            }
            if(selection.mode === "count" && (!selection.value || selection.value <= 0)){
              alert("반복 횟수를 1 이상으로 입력해주세요.");
              return;
            }
            entry.item.recurring_end_override = selection;
          }
        }

        const res = await fetch(apiBase + "/nlp-apply-add", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ items: selected })
        });

        if(!res.ok){
          alert("일정 추가 적용에 실패했습니다.");
          return;
        }
        const created = await res.json();
        if(Array.isArray(created)){
          recordUndoBatch(created);
        }
        markLocalCacheDirty();

        closeConfirm();
        resetNlpComposerInputs();
        await refreshAll();
        return;
      }

      if(confirmState.mode === "delete"){
        const ids = Array.from(document.querySelectorAll("input[type=checkbox][data-delete-id]"))
          .filter(x => x.checked)
          .map(x => parseInt(x.dataset.deleteId, 10))
          .filter(n => Number.isFinite(n));

        if(ids.length === 0){
          alert("삭제할 항목을 선택해주세요.");
          return;
        }

        const res = await fetch(apiBase + "/delete-by-ids", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ ids })
        });

        if(!res.ok){
          alert("일정 삭제 적용에 실패했습니다.");
          return;
        }
        markLocalCacheDirty();

        closeConfirm();
        resetNlpComposerInputs();
        await refreshAll();
        return;
      }
    });
  });
</script>
</body>
</html>
