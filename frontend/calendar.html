
<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>캘린더</title>

  <script src="https://cdn.jsdelivr.net/npm/fullcalendar@6.1.15/index.global.min.js"></script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link
    href="https://fonts.googleapis.com/css2?family=Noto+Sans+KR:wght@400;500;700&display=swap"
    rel="stylesheet"
  >

  <style>
    :root{
      --bg:#fbfbf9;
      --card:#ffffff;
      --text:#2f3437;
      --muted:#6b6f73;
      --border:#e7e7e4;

      --primary:#2f6feb;
      --danger:#ef4444;

      --radius:14px;
      --shadow:none;

      --sidebar-w: 360px;
      --ctl-h: 34px;
      --topbar-ctl-h: 34px;
      --icon-size: 18px;
      --icon-btn-size: var(--topbar-ctl-h);
      --topbar-btn-bg: var(--bg);
      --topbar-btn-bg-hover: var(--bg);
      --topbar-group-bg: var(--bg);
      --topbar-elev-shadow: 0 0 26px rgba(15,18,20,.11);
      --topbar-ink: #1f2326;
      --topbar-active-bg: rgba(47,52,55,.16);
      --topbar-active-ink: var(--primary);
      --block-side-gap: 22px;
      --block-vert-gap: 22px;
      --outline-white: #fff;
      --outline-width: 2px;
      --modal-shadow: 0 8px 20px rgba(0,0,0,.18);
      --modal-border: #fff;
    }

    *{box-sizing:border-box;}
    html, body{height:100%;}
    body{
      margin:0;
      font-family:"Noto Sans KR", system-ui, -apple-system, "Segoe UI", sans-serif;
      background:var(--bg);
      color:var(--text);
      font-weight:500;
    }
    input, textarea, button, select{ font-family:inherit; }

    header{
      position:sticky;
      top:0;
      z-index:30;
      background:transparent;
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border-bottom:0;
    }

    .topbar{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:10px 14px;
      gap:12px;
      max-width: 1400px;
      margin:0 auto;
    }

    .topbar-left{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
    }

    .app-icon-slot{
      width:var(--ctl-h);
      height:var(--ctl-h);
      border-radius:10px;
      background:#fff;
      border:1px dashed var(--border);
      flex:0 0 auto;
    }

    .divider{
      width:1px;
      height:18px;
      background:var(--border);
      flex:0 0 auto;
    }

    .nav-group{
      display:inline-flex;
      align-items:center;
      gap:0;
      padding:0;
      height:var(--topbar-ctl-h);
      border-radius:999px;
      background:var(--topbar-group-bg);
      flex:0 0 auto;
      box-shadow: var(--topbar-elev-shadow);
    }
    .nav-btn{
      height:var(--icon-btn-size);
      padding:0 12px;
      border:0;
      border-radius:999px;
      background:var(--topbar-btn-bg);
      color:var(--topbar-ink);
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      gap:6px;
    }
    .nav-btn.is-circle{
      width:var(--icon-btn-size);
      padding:0;
      justify-content:center;
    }
    .nav-btn.is-circle span{
      font-size:var(--icon-size);
      line-height:1;
    }
    .nav-btn > span{
      display:inline-block;
    }
    .nav-btn:hover{background:var(--topbar-btn-bg-hover);}

    .ym-label{
      display:flex;
      align-items:center;
      height:var(--topbar-ctl-h);
      font-size:22px;
      font-weight:900;
      letter-spacing:-0.2px;
      padding:0 4px;
      white-space:nowrap;
      flex:0 0 auto;
    }
    .month-label{
      position:absolute;
      top:12px;
      left:28px;
      font-size:28px;
      font-weight:900;
      color:var(--text);
      background:transparent;
      border:0;
      padding:0;
      z-index:5;
      pointer-events:none;
    }

    .topbar-right{
      display:flex;
      align-items:center;
      gap:10px;
      flex:0 0 auto;
    }

    .event-search{
      position:relative;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height:var(--icon-btn-size);
      width:var(--icon-btn-size);
      border-radius:999px;
      background:transparent;
      overflow:visible;
    }
    .event-search-field{
      position:absolute;
      right:calc(100% + 6px);
      top:0;
      height:100%;
      display:flex;
      align-items:center;
      gap:4px;
      border:0;
      border-radius:999px;
      background:var(--topbar-group-bg);
      padding:0 4px 0 8px;
      width:0;
      opacity:0;
      pointer-events:none;
      transition:width 180ms ease, opacity 160ms ease;
      box-shadow: var(--topbar-elev-shadow);
    }
    .event-search.is-open .event-search-field{
      width:180px;
      opacity:1;
      pointer-events:auto;
    }
    .event-search-field input{
      border:0;
      outline:none;
      background:transparent;
      color:var(--text);
      font-size:13px;
      padding:0 2px;
      min-width:0;
      width:auto;
      flex:1 1 auto;
    }
    .event-search input::placeholder{ color:var(--muted); }
    .event-search-settings-btn{
      width:var(--icon-btn-size);
      height:var(--icon-btn-size);
      border:0;
      border-radius:999px;
      background:var(--topbar-btn-bg);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      color:var(--topbar-ink);
      cursor:pointer;
      margin-left:0;
      outline:none;
      box-shadow:none;
    }
    .event-search .event-search-settings-btn{
      border:0;
      background:var(--topbar-btn-bg);
    }
    .event-search-settings-btn:focus-visible{
      outline:none;
      box-shadow:none;
    }
    .event-search-settings-btn:hover{ background:var(--topbar-btn-bg-hover); color:var(--topbar-ink); }
    .event-search-settings-btn svg{
      width:var(--icon-size);
      height:var(--icon-size);
      fill:currentColor;
    }

    .event-search-popover{
      position:absolute;
      right:0;
      top:calc(100% + 8px);
      display:inline-flex;
      flex-direction:column;
      width:max-content;
      min-width:160px;
      max-width:220px;
      background:var(--topbar-group-bg);
      border:0;
      border-radius:12px;
      padding:10px 12px 12px;
      box-shadow: var(--topbar-elev-shadow);
      z-index:40;
      opacity:0;
      transform:translateY(-4px);
      pointer-events:none;
      transition:opacity 160ms ease, transform 160ms ease;
    }
    .event-search.is-range-open .event-search-popover{
      opacity:1;
      transform:translateY(0);
      pointer-events:auto;
    }
    .event-search-popover .popover-title{
      font-size:12px;
      color:var(--muted);
      margin-bottom:8px;
      padding-right:36px;
      text-align:left;
    }
    .event-search-popover .popover-row{
      display:flex;
      align-items:center;
      gap:8px;
      margin-bottom:8px;
      font-size:12px;
      color:var(--muted);
    }
    .event-search-popover .popover-row:last-of-type{
      margin-bottom:0;
    }
    .event-search-popover .popover-row input{
      width:44px;
      text-align:center;
      font-size:12px;
      color:var(--topbar-ink);
      padding:4px 6px;
      border:1px solid rgba(47,52,55,.16);
      border-radius:8px;
      outline:none;
      background:var(--topbar-btn-bg);
      flex:0 0 auto;
    }
    .event-search-popover .popover-row input::-webkit-outer-spin-button,
    .event-search-popover .popover-row input::-webkit-inner-spin-button{
      -webkit-appearance:none;
      margin:0;
    }
    .event-search-popover .popover-row input[type="number"]{
      -moz-appearance:textfield;
    }
    .event-search-popover .popover-actions{
      display:flex;
      justify-content:flex-end;
      margin-top:8px;
    }
    .event-search-popover .popover-actions button{
      border:0;
      background:var(--topbar-btn-bg);
      color:var(--topbar-ink);
      width:24px;
      height:24px;
      padding:0;
      border-radius:999px;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-size:11px;
      line-height:1;
      box-shadow: var(--topbar-elev-shadow);
    }
    .event-search-popover .popover-actions button:hover{
      background:var(--topbar-btn-bg-hover);
      color:var(--topbar-ink);
    }
    .event-search-popover .popover-close{
      position:absolute;
      top:8px;
      right:8px;
      border:0;
      background:var(--topbar-btn-bg);
      color:var(--topbar-ink);
      font-size:12px;
      width:24px;
      height:24px;
      border-radius:999px;
      cursor:pointer;
      box-shadow: var(--topbar-elev-shadow);
    }
    .event-search-popover .popover-close:hover{
      background:var(--topbar-btn-bg-hover);
      color:var(--topbar-ink);
    }
    .event-search button{
      width:var(--icon-btn-size);
      height:var(--icon-btn-size);
      border:1px solid transparent;
      background:var(--topbar-btn-bg);
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      color:var(--topbar-ink);
    }
    .event-search button.event-search-settings-btn{
      border:0;
      background:transparent;
      box-shadow:none;
    }
    .event-search button:hover{ background:var(--topbar-btn-bg-hover); color:var(--topbar-ink); }
    .event-search svg{ width:var(--icon-size); height:var(--icon-size); fill:currentColor; }

    .view-switch{
      position:relative;
      isolation:isolate;
      display:inline-flex;
      align-items:center;
      gap:4px;
      padding:2px;
      height:var(--topbar-ctl-h);
      border-radius:999px;
      border:0;
      background:var(--topbar-group-bg);
      box-shadow: var(--topbar-elev-shadow);
    }
    .view-switch-indicator{
      position:absolute;
      top:0;
      left:0;
      width:30px;
      height:30px;
      border-radius:999px;
      background:var(--topbar-active-bg);
      transition:transform .22s ease, width .22s ease, height .22s ease;
      will-change:transform, width, height;
      z-index:0;
      pointer-events:none;
    }
    .view-btn{
      width:30px;
      height:30px;
      padding:0;
      border-radius:999px;
      border:0;
      background:transparent;
      color:var(--topbar-ink);
      cursor:pointer;
      position:relative;
      z-index:1;
    }
    .view-btn > span{
      display:inline-block;
    }
    .view-btn:hover{background:var(--topbar-btn-bg-hover); color:var(--topbar-ink);}
    .view-btn.active{
      background:transparent;
      color:var(--topbar-active-ink);
    }

    .header-actions{
      display:flex;
      align-items:center;
      gap:8px;
      padding:2px 6px;
      border-radius:999px;
      background:var(--topbar-group-bg);
      box-shadow: var(--topbar-elev-shadow);
    }
    .badge{
      display:inline-flex;
      align-items:center;
      padding:.25rem .55rem;
      border-radius:999px;
      font-size:.78rem;
      font-weight:800;
      border:1px solid var(--border);
      background:#fff;
      color:var(--text);
      white-space:nowrap;
    }
    .badge.linked{
      background:#eaf6ee;
      border-color:#c8e9d3;
      color:#1f6f3d;
    }
    .badge.admin{
      background:#fff3d8;
      border-color:#ffe1a6;
      color:#7a4b00;
    }
    .header-btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      height:var(--topbar-ctl-h);
      padding:0 12px;
      border-radius:10px;
      border:1px solid transparent;
      background:var(--topbar-btn-bg);
      color:var(--topbar-ink);
      text-decoration:none;
      font-size:.82rem;
      font-weight:800;
      white-space:nowrap;
    }
    .header-btn:hover{ background:var(--topbar-btn-bg-hover); }
    .header-actions .header-btn{
      box-shadow:none;
    }
    .menu-btn{
      width:var(--topbar-ctl-h);
      height:var(--topbar-ctl-h);
      border-radius:999px;
      border:1px solid transparent;
      background:var(--topbar-btn-bg);
      color:var(--topbar-ink);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      cursor:pointer;
      flex:0 0 auto;
    }
    .menu-btn:hover{ background:var(--topbar-btn-bg-hover); }
    .menu-btn svg{
      width:var(--icon-size);
      height:var(--icon-size);
      fill:currentColor;
    }
    .topbar .nav-btn,
    .topbar .view-btn,
    .topbar #event-search-btn,
    .topbar .icon-btn,
    .topbar .menu-btn,
    .event-search-settings-btn,
    .event-search-popover .popover-actions button,
    .event-search-popover .popover-close{
      overflow:visible;
    }
    .topbar .nav-btn > span,
    .topbar .nav-btn > strong,
    .topbar .view-btn > span,
    .topbar .view-btn > strong{
      transition:transform .12s ease;
      transform-origin:center;
    }
    .topbar .nav-btn:hover > span,
    .topbar .nav-btn:hover > strong,
    .topbar .view-btn:hover > span,
    .topbar .view-btn:hover > strong{
      transform:scale(1.16);
    }
    .topbar .nav-btn:active > span,
    .topbar .nav-btn:active > strong,
    .topbar .view-btn:active > span,
    .topbar .view-btn:active > strong{
      transform:scale(.85);
    }
    .topbar #event-search-btn,
    .topbar .icon-btn,
    .topbar .menu-btn,
    .event-search-settings-btn,
    .event-search-popover .popover-actions button,
    .event-search-popover .popover-close{
      transition:transform .12s ease;
      transform-origin:center;
    }
    .topbar #event-search-btn:hover,
    .topbar .icon-btn:hover,
    .topbar .menu-btn:hover,
    .event-search-settings-btn:hover,
    .event-search-popover .popover-actions button:hover,
    .event-search-popover .popover-close:hover{
      transform:scale(1.16);
    }
    .topbar #event-search-btn:active,
    .topbar .icon-btn:active,
    .topbar .menu-btn:active,
    .event-search-settings-btn:active,
    .event-search-popover .popover-actions button:active,
    .event-search-popover .popover-close:active{
      transform:scale(.85);
    }
    .topbar-right .primary-btn{
      height:var(--topbar-ctl-h);
      padding:0 12px;
      margin-top:0;
      align-self:center;
      background:var(--topbar-btn-bg);
      border-color:transparent;
      color:var(--topbar-ink);
    }
    .topbar .primary-btn:hover{
      background:var(--topbar-btn-bg-hover);
    }
    .topbar-right .primary-btn.icon-btn{
      height:var(--icon-btn-size);
      padding:0;
    }
    .icon-btn{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:var(--icon-btn-size);
      padding:0;
      position:relative;
    }
    .circle-btn{
      border-radius:999px;
    }
    .icon-btn.circle-btn{
      width:var(--icon-btn-size);
      height:var(--icon-btn-size);
    }
    .icon-btn svg{
      width:var(--icon-size);
      height:var(--icon-size);
      fill:currentColor;
    }
    .topbar .menu-btn,
    .topbar .event-search button,
    .topbar .header-btn,
    .topbar .primary-btn{
      box-shadow: var(--topbar-elev-shadow);
    }
    .topbar .event-search button.event-search-settings-btn{
      box-shadow:none;
    }
    .icon-badge{
      position:absolute;
      top:-6px;
      right:-6px;
      min-width:18px;
      height:18px;
      padding:0 5px;
      border-radius:999px;
      background:#111;
      color:#fff;
      font-size:10px;
      font-weight:900;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border:2px solid #fff;
      box-sizing:border-box;
    }
    .icon-badge.is-hidden{
      display:none;
    }

    /* ===== Layout: calendar left, utilities right ===== */
    .app{
      display:grid;
      grid-template-columns: 1fr var(--sidebar-w);
      gap:12px;
      padding:12px;
      max-width: 1400px;
      margin:0 auto;
      align-items:start;
    }

    .tool-overlay{
      position:fixed;
      inset:0;
      background:transparent;
      opacity:0;
      pointer-events:none;
      transition:opacity .25s ease;
      z-index:40;
    }
    .tool-overlay.active{
      opacity:1;
      pointer-events:auto;
    }
    .tool-drawer{
      position:fixed;
      top:0;
      right:0;
      height:100%;
      width:min(320px, 86vw);
      background:rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: var(--modal-shadow);
      border-left:1px solid var(--modal-border);
      transform:translateX(100%);
      transition:transform .3s ease;
      z-index:50;
      display:flex;
      flex-direction:column;
    }
    .tool-drawer.active{
      transform:translateX(0);
    }
    .tool-drawer-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      padding:16px;
      border-bottom:1px solid var(--modal-border);
    }
    .tool-drawer-title{
      font-size:16px;
      font-weight:900;
      letter-spacing:-0.2px;
    }
    .tool-close{
      width:32px;
      height:32px;
      border-radius:999px;
      border:1px solid var(--modal-border);
      background:#fff;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
    }
    .tool-close:hover{ background:#f2f2f0; }
    .tool-drawer-body{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:10px;
    }
    .tool-link{
      display:inline-flex;
      align-items:center;
      justify-content:space-between;
      padding:12px 14px;
      border-radius:12px;
      border:1px solid var(--modal-border);
      background:#fff;
      color:var(--text);
      text-decoration:none;
      font-weight:800;
    }
    .tool-link:hover{ background:#f2f2f0; }
    body.drawer-open{
      overflow:hidden;
    }

    main{
      min-width:0;
      padding:var(--block-vert-gap) var(--block-side-gap);
    }
    aside{
      position:sticky;
      top:62px;
      align-self:start;
      height: calc(100vh - 74px);
      overflow:auto;
      padding:var(--block-vert-gap) var(--block-side-gap);
      display:flex;
      flex-direction:column;
      gap:var(--block-vert-gap);
    }

    .panel{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:12px;
      margin-bottom:12px;
    }
    .panel.composer{
      padding:8px;
    }
    .topbar-block{
      background:var(--topbar-group-bg);
      border:0;
      box-shadow:var(--topbar-elev-shadow);
      margin:0;
    }
    .panel,
    .topbar-block,
    .nav-group,
    .view-switch,
    .header-actions,
    .composer-input-wrap,
    .event-search-field,
    .event-search-popover,
    .seg-toggle,
    .tool-link,
    .tool-close,
    .recent-delete,
    .recent-close{
      border:var(--outline-width) solid var(--outline-white);
    }
    button{
      border:var(--outline-width) solid var(--outline-white) !important;
    }
    .nav-group .nav-btn,
    .view-switch .view-btn{
      border-color:transparent !important;
    }
    .nav-group .nav-btn{
      padding:0 2px;
    }
    .nav-group .nav-btn.is-circle{
      padding:0;
    }
    .topbar-block,
    .composer-input-wrap,
    .nav-group,
    .view-switch,
    .header-actions,
    .topbar .menu-btn,
    .topbar .event-search button{
      position:relative;
      z-index:20;
    }
    .event-search-field{
      z-index:30;
    }
    .calendar-shell.topbar-block{
      background:var(--topbar-group-bg);
      border:var(--outline-width) solid var(--outline-white);
      box-shadow:var(--topbar-elev-shadow);
    }
    .calendar-events-slot{
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* ===== Calendar ===== */
    #calendar-container{
      position:relative;
      width:100%;
      overflow:visible;
    }
    .calendar-shell{
      background:var(--card);
      border:1px solid var(--border);
      border-radius:var(--radius);
      box-shadow:var(--shadow);
      padding:10px 10px 0;
      position:relative;
      overflow:hidden;
      z-index:2;
    }
    #calendar-container.is-year-view .calendar-shell{
      display:none;
    }
    #calendar-container.is-year-view #month-label{
      display:none;
    }
    #calendar{
      padding-top:52px;
    }
    .calendar-main-content{
      position:relative;
      display:flex;
      flex-direction:column;
      gap:0;
      min-height:100%;
      opacity:1;
      transform:scale(1);
      transform-origin: var(--year-origin-x) var(--year-origin-y);
      transition:none;
    }
    .calendar-main-content.is-fading{
      opacity:0;
    }
    #year-view{
      display:none;
      padding:10px;
      opacity:0;
      position:relative;
      z-index:1;
      transition:none;
      overflow:visible;
    }
    #year-view.active{
      display:block;
    }
    #year-view.is-visible{
      opacity:1;
    }
    .year-grid{
      display:grid;
      grid-template-columns:repeat(4, minmax(0, 1fr));
      gap:16px;
      width:100%;
      max-width:none;
      margin:0 auto;
    }
    @media (max-width: 1200px){
      .year-grid{
        grid-template-columns:repeat(3, minmax(0, 1fr));
        max-width:none;
      }
    }
    @media (max-width: 900px){
      .year-grid{
        grid-template-columns:repeat(3, minmax(0, 1fr));
        max-width:none;
      }
    }
    @media (max-width: 620px){
      .year-grid{
        grid-template-columns:repeat(2, minmax(0, 1fr));
        max-width:none;
      }
    }
    @media (max-width: 420px){
      .year-grid{
        grid-template-columns:1fr;
        max-width:none;
      }
    }
    .year-card{
      border:var(--outline-width) solid var(--outline-white);
      border-radius:12px;
      padding:10px;
      background:#fff;
      cursor:pointer;
      transition:background 160ms ease, border-color 160ms ease;
      display:flex;
      flex-direction:column;
      align-items:stretch;
      box-shadow:0 6px 16px rgba(0,0,0,.12);
    }
    .year-card:hover{
      background:#f7f7f5;
      border-color:var(--outline-white);
    }
    .year-card-title{
      font-size:13px;
      color:var(--muted);
      margin-bottom:8px;
      font-weight:700;
      text-align:center;
    }
    .mini-weekdays{
      display:grid;
      grid-template-columns:repeat(7, 1fr);
      gap:3px;
      margin-bottom:6px;
    }
    .mini-weekdays span{
      font-size:11px;
      color:var(--muted);
      text-align:center;
      line-height:14px;
    }
    .mini-days{
      display:grid;
      grid-template-columns:repeat(7, 1fr);
      gap:3px;
    }
    .mini-day{
      font-size:11px;
      color:var(--text);
      text-align:center;
      line-height:16px;
      height:16px;
    }
    .mini-day.is-empty{
      color:transparent;
    }
    .mini-day.is-today{
      background:#111;
      color:#fff;
      border-radius:999px;
      width:16px;
      height:16px;
      margin:0 auto;
      display:flex;
      align-items:center;
      justify-content:center;
    }
    #calendar-container .calendar-events-panel{
      margin:0;
      border:0;
      box-shadow:none;
      padding-top:6px;
      padding-bottom:6px;
    }
    .calendar-events-panel{
      padding-top:8px;
      padding-bottom:8px;
    }
    .calendar-events-panel.is-detached{
      margin:0;
    }

    #calendar .fc{
      font-size:0.92rem;
      color:var(--text);
    }
    #calendar .fc .fc-view-harness{
      min-height:0 !important;
    }
    #calendar .fc-theme-standard td,
    #calendar .fc-theme-standard th{
      border-color:var(--border);
    }
    #calendar .fc-theme-standard td,
    #calendar .fc-theme-standard th{
      border-left:0;
      border-right:0;
    }
    #calendar .fc-theme-standard .fc-scrollgrid td,
    #calendar .fc-theme-standard .fc-scrollgrid th{
      border-left:0 !important;
      border-right:0 !important;
    }
    #calendar .fc-daygrid-day,
    #calendar .fc-daygrid-day-frame,
    #calendar .fc-scrollgrid-section-header th,
    #calendar .fc-scrollgrid-section-body td{
      border-left:0 !important;
      border-right:0 !important;
    }
    #calendar .fc-scrollgrid{ border:0; }
    #calendar .fc-col-header-cell-cushion{
      color:var(--muted);
      padding:0 4px;
      font-size:12px;
      display:block;
      line-height:22px;
      text-align:center;
      min-height:22px;
    }
    #calendar .fc-col-header{
      border-top:1px solid var(--border);
    }
    #calendar .fc-daygrid-day-number{
      color:var(--text);
      padding:7px 8px;
      display:block;
      text-align:center;
      margin:0 auto;
      line-height:26px;
    }
    #calendar .fc-daygrid-day-top{
      justify-content:center;
    }
    #calendar .fc-day-today{
      background: transparent !important;
    }
    #calendar .fc-day-today .fc-daygrid-day-frame{
      background: transparent !important;
    }
    #calendar .fc-day-today .fc-daygrid-day-number{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      width:26px;
      height:26px;
      border-radius:50%;
      background:#111;
      color:#fff;
      padding:0;
      margin:7px auto 0;
      line-height:26px;
    }
    #calendar .fc .fc-daygrid-event{
      background:transparent;
      border:0;
      color:var(--text);
      padding:2px 6px 2px 18px;
      border-radius:8px;
      position:relative;
    }
    #calendar .fc .fc-daygrid-event:hover{ background:#f2f2f0; }
    #calendar .fc .fc-daygrid-event::before{
      content:"";
      width:6px;
      height:6px;
      border-radius:50%;
      background:var(--primary);
      position:absolute;
      left:8px;
      top:50%;
      transform:translateY(-50%);
      opacity:.9;
    }
    #calendar .fc .fc-daygrid-event .fc-event-title{ font-weight:900; }
    #calendar .fc .fc-daygrid-more-link{
      color:var(--muted);
      font-weight:900;
    }
    #calendar .fc .fc-daygrid-more-link:hover{ color:var(--text); }

    /* ✅ 선택 날짜 하이라이트 */
    #calendar .fc-daygrid-day.selected-day{
      background: rgba(47,111,235,.10) !important;
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-day-frame{
      border-radius: 10px;
      box-shadow: inset 0 0 0 2px rgba(47,111,235,.28);
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-day-number{
      color:#111 !important;
      font-weight:900;
    }
    #calendar .fc-daygrid-day.selected-day a,
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-day-top{
      color:#111 !important;
    }
    #calendar .fc-daygrid-day.fc-day-today .fc-daygrid-day-number{
      color:#fff !important;
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-event{
      background: rgba(47,111,235,.18);
      color:#15233c;
    }
    #calendar .fc-daygrid-day.selected-day .fc-daygrid-event::before{
      background:#1c3b7a;
    }
    #calendar .fc .selected-day-header{
      background: rgba(47,111,235,.10);
      color:#1d3360;
      font-weight:900;
    }
    #calendar .fc .fc-timegrid-col.selected-day .fc-timegrid-col-frame{
      background: rgba(47,111,235,.08);
      box-shadow: inset 0 0 0 2px rgba(47,111,235,.2);
    }
    #calendar .fc .fc-timegrid-col.selected-day .fc-timegrid-event{
      background: rgba(47,111,235,.2);
      border-color: rgba(47,111,235,.3);
      color:#15233c;
    }

    body.global-loading-active #calendar-container .calendar-main-content{
      filter:blur(10px);
      pointer-events:none;
    }
    body.global-loading-active #calendar-container #global-loading-overlay{
      filter:none;
    }


    /* ===== NLP Composer ===== */
    .composer textarea{
      width:100%;
      border:0;
      border-radius:0;
      padding:6px 4px;
      font-size:14px;
      line-height:1.45;
      outline:none;
      resize:none;
      background:transparent;
      color:var(--text);
      min-height:28px;
      height:28px;
      overflow:hidden;
      transition: height .18s cubic-bezier(.25,.8,.25,1);
    }

    .composer-input-wrap{
      --composer-gap: 8px;
      --composer-row-gap: 6px;
      display:flex;
      align-items:center;
      gap:var(--composer-gap);
      border:0;
      border-radius:var(--composer-pill-radius, 999px);
      padding:6px 6px;
      background:var(--topbar-group-bg);
      box-shadow:var(--topbar-elev-shadow);
    }
    .nlp-chat{
      display:flex;
      flex-direction:column;
      gap:8px;
      margin-bottom:10px;
    }
    .nlp-chat:empty{
      display:none;
    }
    .nlp-msg{
      max-width:100%;
      padding:8px 12px;
      border-radius:14px;
      font-size:13px;
      line-height:1.45;
      color:var(--topbar-ink);
      background:var(--topbar-group-bg);
      box-shadow:var(--topbar-elev-shadow);
      border:var(--outline-width) solid var(--outline-white);
      word-break:keep-all;
      white-space:pre-wrap;
    }
    .nlp-msg strong{
      font-weight:700;
    }
    .nlp-msg em{
      font-style:italic;
    }
    .nlp-msg ul{
      margin:6px 0;
      padding-left:18px;
    }
    .nlp-msg li{
      margin:2px 0;
    }
    .nlp-msg.user{
      align-self:flex-end;
      background:var(--topbar-active-bg);
    }
    .nlp-msg.assistant{
      align-self:flex-start;
    }
    .composer-left{
      display:flex;
      align-items:center;
      gap:8px;
    }
    .composer-input-wrap.is-multiline{
      display:grid;
      grid-template-columns:1fr auto;
      grid-template-rows:auto auto;
      grid-template-areas:
        "input input"
        "left action";
      align-items:end;
      row-gap:var(--composer-row-gap);
      column-gap:var(--composer-gap);
    }
    .composer-input-wrap.is-multiline textarea{
      grid-area:input;
    }
    .composer-input-wrap.is-multiline .composer-left{
      grid-area:left;
    }
    .composer-input-wrap.is-multiline .inline-action{
      grid-area:action;
      justify-self:end;
    }
    .composer-input-wrap:focus-within{
      box-shadow:var(--topbar-elev-shadow);
    }
    .composer-input-wrap textarea{
      flex:1 1 auto;
      min-width:0;
    }
    .composer-left,
    .composer-input-wrap .inline-action,
    .composer-input-wrap textarea{
      will-change:transform, opacity;
    }

    .seg-toggle{
      display:inline-flex;
      align-items:center;
      gap:0;
      border:0;
      background:var(--topbar-group-bg);
      border-radius:999px;
      padding:2px;
      height:var(--topbar-ctl-h);
      box-shadow:var(--topbar-elev-shadow);
    }
    .seg-toggle input{ display:none; }
    .seg{
      width:calc(var(--topbar-ctl-h) - 4px);
      height:calc(var(--topbar-ctl-h) - 4px);
      padding:0;
      border-radius:999px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      font-size:12px;
      color:var(--topbar-ink);
      cursor:pointer;
      user-select:none;
      background:transparent;
      border:0;
      transition:background .15s ease, color .15s ease;
    }
    .seg svg{
      width:14px;
      height:14px;
      fill:currentColor;
      transition:transform .12s ease;
    }
    .seg:hover svg{ transform:scale(1.16); }
    .seg:active svg{ transform:scale(.85); }
    #nlp-mode-toggle:not(:checked) ~ .seg.add{
      background:var(--topbar-active-bg);
      color:var(--topbar-active-ink);
    }
    #nlp-mode-toggle:checked ~ .seg.del{
      background:var(--topbar-active-bg);
      color:#8a1f1f;
    }

    .inline-action{
      position:relative;
      width:var(--ctl-h);
      height:var(--ctl-h);
      flex:0 0 auto;
    }
    .inline-action > *{ position:absolute; inset:0; }

    .Btn{
      width:var(--ctl-h);
      height:var(--ctl-h);
      border-radius:999px;
      border:1px solid var(--border);
      background:#fff;
      cursor:pointer;
      display:flex;
      align-items:center;
      justify-content:center;
      transition:transform .15s ease, background .15s ease, opacity .35s ease;
    }
    .Btn:hover{ background:#f2f2f0; }
    .Btn:active{ transform:translateY(1px); }
    .Btn.mode-delete{ border-color: rgba(239,68,68,.35); }

    .Btn .sign svg{ width:20px; height:20px; }
    .Btn .sign svg path{ fill: var(--text); }
    .Btn.mode-delete .sign svg path{ fill: #8a1f1f; }
    #nlp-action-btn{
      background:#111;
      border:0 !important;
      transition:transform .12s ease, background .15s ease;
    }
    #nlp-action-btn:hover{ background:#222; }
    #nlp-action-btn:hover{ transform:scale(1.16); }
    #nlp-action-btn:active{ transform:scale(.85); }
    #nlp-action-btn .sign svg path{ fill:#fff; }
    #nlp-action-btn.mode-delete{
      border:0 !important;
    }
    #nlp-action-btn.mode-delete .sign svg path{ fill:#fff; }

    .scale-0{transform:scale(.95); opacity:0; pointer-events:none;}
    .scale-1{transform:scale(1); opacity:1;}

    .loader-wrapper{
      display:inline-flex;
      align-items:center;
      justify-content:center;
      transition:opacity .35s ease, transform .35s ease;
    }
    .loader{
      width:18px;
      height:18px;
      border-radius:50%;
      border:2px solid rgba(47,52,55,.18);
      border-top-color: rgba(47,52,55,.55);
      animation:spin 0.9s linear infinite;
    }
    .loader.is-delete{
      border-color: rgba(239,68,68,.18);
      border-top-color: rgba(239,68,68,.6);
    }
    @keyframes spin{ to{ transform:rotate(360deg); } }

    .attach-btn{
      width:var(--icon-btn-size);
      height:var(--icon-btn-size);
      display:inline-flex;
      align-items:center;
      justify-content:center;
      border-radius:999px;
      background:var(--topbar-btn-bg);
      color:var(--topbar-ink);
      box-shadow:var(--topbar-elev-shadow);
      cursor:pointer;
      transition:transform .12s ease, background .15s ease;
    }
    .attach-btn svg{
      width:var(--icon-size);
      height:var(--icon-size);
      fill:currentColor;
    }
    .attach-btn:hover{ background:#f2f2f0; }
    .attach-btn:hover{ transform:scale(1.16); }
    .attach-btn:active{ transform:scale(.85); }
    .image-attachments{
      margin-top:10px;
      display:flex;
      flex-wrap:wrap;
      gap:10px;
    }
    .image-attachments:empty{
      margin-top:0;
    }
    .image-chip{
      width:92px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fff;
      padding:6px;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .image-chip img{
      width:100%;
      height:60px;
      object-fit:cover;
      border-radius:8px;
      border:1px solid rgba(0,0,0,.05);
    }
    .image-chip-actions{
      display:flex;
      gap:4px;
    }
    .image-chip-actions button{
      flex:1 1 auto;
      border:1px solid var(--border);
      border-radius:8px;
      background:#fff;
      font-size:11px;
      font-weight:700;
      cursor:pointer;
      padding:2px 0;
    }
    .image-chip-actions button:hover{
      background:#f2f2f0;
    }

    #image-editor-overlay{
      position:fixed;
      inset:0;
      z-index:2000;
      background:transparent;
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
    }
    #image-editor-overlay.active{ display:flex; }
    .image-editor-modal{
      background:rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      box-shadow: var(--modal-shadow);
      border:1px solid var(--modal-border);
      border-radius:16px;
      width:min(920px, 96vw);
      max-height:90vh;
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:16px;
    }
    .image-editor-head{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .image-editor-title{
      font-size:18px;
      font-weight:800;
    }
    .image-editor-meta{
      font-size:13px;
      color:var(--muted);
    }
    .image-editor-canvas{
      border:1px solid var(--border);
      border-radius:14px;
      background:#f9f9f7;
      padding:12px;
      overflow:auto;
      flex:1 1 auto;
    }
    .image-editor-canvas-inner{
      position:relative;
      display:inline-block;
    }
    #image-editor-canvas,
    #image-editor-selection{
      display:block;
      max-width:100%;
      border-radius:10px;
    }
    #image-editor-selection{
      position:absolute;
      left:0;
      top:0;
      pointer-events:auto;
      cursor:crosshair;
      touch-action:none;
    }
    .image-editor-foot{
      display:flex;
      align-items:center;
      gap:10px;
    }
    .image-editor-foot .spacer{
      flex:1 1 auto;
    }
    .image-editor-foot button{
      border-radius:10px;
      border:1px solid var(--border);
      background:#fff;
      font-weight:800;
      padding:6px 14px;
      cursor:pointer;
    }
    .image-editor-foot button.primary{
      background:var(--text);
      border-color:var(--text);
      color:#fff;
    }
    .image-editor-foot button:hover:not(.primary){
      background:#f2f2f0;
    }

    .scope-controls{
      margin-top:10px;
      padding:10px;
      border:1px solid var(--border);
      border-radius:12px;
      background:#fffaf5;
      display:none;
    }
    .scope-title{
      font-size:12px;
      font-weight:900;
      color:#7a3a00;
      margin-bottom:6px;
    }
    .scope-row{
      display:flex;
      align-items:center;
      gap:8px;
      flex-wrap:wrap;
    }
    .scope-row input[type="date"]{
      flex:1;
      min-width:120px;
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 8px;
      font-size:13px;
      font-weight:700;
    }

    .reasoning-controls{
      margin-top:10px;
      padding:10px;
      border:1px dashed var(--border);
      border-radius:12px;
      background:#f0f4ff;
      display:none;
      align-items:center;
      justify-content:space-between;
      gap:10px;
    }
    .reasoning-controls label{
      font-size:12px;
      font-weight:900;
      color:#1c3b7a;
    }
    .reasoning-controls select{
      border:1px solid var(--border);
      border-radius:10px;
      padding:6px 10px;
      font-size:13px;
      font-weight:700;
      background:#fff;
      min-width:120px;
    }

    .rec-end-box{
      margin-top:10px;
      padding:10px;
      border:1px dashed var(--border);
      border-radius:12px;
      background:#fffdf5;
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .rec-end-box h3{
      margin:0;
      font-size:12px;
      font-weight:900;
      color:#7a3a00;
    }
    .rec-end-options{
      display:flex;
      flex-wrap:wrap;
      gap:8px;
    }
    .rec-end-option{
      display:flex;
      align-items:center;
      gap:4px;
      font-size:12px;
      font-weight:800;
      color:#4a3b21;
    }
    .rec-end-extra{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
    }
    .rec-end-extra input[type="date"],
    .rec-end-extra input[type="number"]{
      border:1px solid var(--border);
      border-radius:8px;
      padding:4px 8px;
      font-size:12px;
      font-weight:800;
      min-width:140px;
    }

    /* ===== Quick add ===== */
    /* ===== Selected date list ===== */
  #events-ul{list-style:none; padding:0; margin:0;}
  #events-ul li{
    padding:10px 6px;
    border-bottom:1px solid var(--border);
    display:flex;
    align-items:center;
    gap:10px;
    cursor:pointer;
  }
  #events-ul li:last-child{
    border-bottom:0;
  }
  #events-ul li.events-empty{
    display:block;
    text-align:center;
    color:var(--muted);
    font-weight:800;
    border-bottom:0;
    cursor:default;
  }
  .event-dot{
    width:8px;
    height:8px;
      border-radius:50%;
      background:var(--primary);
      flex:0 0 auto;
      margin-top:2px;
    }
    .event-info{flex:1; min-width:0;}
    .event-title{
      font-weight:600;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .event-meta{
      color:var(--muted);
      font-size:12px;
      margin-top:2px;
      display:flex;
      align-items:center;
      gap:6px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .location-icon{
      width:12px;
      height:12px;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      flex:0 0 auto;
    }
    .location-icon svg{
      width:12px;
      height:12px;
      fill:var(--muted);
    }
    .event-time{
      display:flex;
      flex-direction:column;
      align-items:flex-end;
      gap:4px;
      flex:0 0 auto;
      color:var(--muted);
      font-size:12px;
      font-weight:400;
    }
    .event-time .time-line{
      white-space:nowrap;
    }
  .delete-btn{
    border:1px solid var(--border);
    background:#fff;
    color:var(--muted);
    font-weight:900;
      border-radius:10px;
      padding:7px 10px;
      cursor:pointer;
      flex:0 0 auto;
    }
  .delete-btn:hover{
    border-color: rgba(239,68,68,.35);
    color:#8a1f1f;
    background: rgba(239,68,68,.06);
  }
  .fc-event,
  .fc-daygrid-event,
  .fc-timegrid-event{
    cursor:pointer;
  }

    /* ===== Confirm Modal ===== */
    #confirm-overlay{
      position:fixed;
      inset:0;
      background:transparent;
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:60;
    }
    #confirm-modal{
      width:min(560px, 100%);
      background:rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border:1px solid var(--modal-border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      overflow:hidden;
    }
    .cm-head{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:12px;
      padding:14px 14px 10px;
      border-bottom:1px solid var(--modal-border);
    }
    .cm-title{ font-weight:900; font-size:14px; }
    .cm-desc{
      margin-top:4px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      line-height:1.4;
    }
    .cm-x{
      border:1px solid var(--modal-border);
      background:#fff;
      border-radius:10px;
      width:34px;
      height:34px;
      cursor:pointer;
      font-weight:900;
    }
    .cm-x:hover{ background:#f2f2f0; }
    .cm-body{
      padding:12px 14px;
      max-height: 56vh;
      overflow:auto;
    }
    .cm-foot{
      display:flex;
      justify-content:flex-end;
      gap:10px;
      padding:12px 14px;
      border-top:1px solid var(--modal-border);
      background: #fafaf9;
    }
    .cm-btn{
      border-radius:12px;
      border:1px solid var(--border);
      padding:10px 12px;
      font-weight:900;
      cursor:pointer;
      background:#fff;
    }
    .cm-btn:hover{ background:#f2f2f0; }
    .cm-btn.primary{
      background: rgba(47,52,55,.10);
    }
    .cm-btn.primary:hover{
      background: rgba(47,52,55,.14);
    }

    .primary-btn{
      height:38px;
      padding:0 12px;
      border-radius:12px;
      border:1px solid var(--border);
      background: rgba(47,52,55,.10);
      color:var(--text);
      font-weight:900;
      cursor:pointer;
      display:inline-flex;
      align-items:center;
      justify-content:center;
      margin-top:8px;
      transition:background .2s ease, opacity .2s ease;
    }
    .primary-btn.circle-btn{
      border-radius:999px;
    }
    .primary-btn:hover{ background: rgba(47,52,55,.14); }
    .primary-btn:disabled{
      opacity:.45;
      cursor:not-allowed;
      background: rgba(47,52,55,.08);
    }

    .cm-row{
      border:1px solid var(--border);
      border-radius:12px;
      padding:10px 10px;
      margin-bottom:8px;
      background:#fff;
    }
    .cm-row-top{
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .cm-left{
      display:flex;
      gap:10px;
      align-items:flex-start;
      min-width:0;
    }
    .cm-check{ margin-top:2px; }
    .cm-main{ min-width:0; }
    .cm-line1{
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .cm-line2{
      margin-top:2px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .cm-line-location{
      margin-top:4px;
      font-size:12px;
      font-weight:800;
      color:var(--muted);
    }
    .cm-mini{
      margin-top:6px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
    }
    .cm-toggle{
      border:1px solid var(--border);
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      font-weight:900;
      cursor:pointer;
      color:var(--muted);
      white-space:nowrap;
    }
    .cm-toggle:hover{ background:#f2f2f0; color:var(--text); }
    .cm-sublist{
      margin-top:10px;
      padding-top:10px;
      border-top:1px solid var(--border);
      display:none;
    }
    .cm-subitem{
      display:flex;
      align-items:flex-start;
      gap:10px;
      padding:8px 6px;
      border-radius:10px;
    }
  .cm-subitem:hover{ background:#f7f7f5; }

  .cm-editable{
    display:inline-flex;
    align-items:center;
    gap:6px;
    cursor:pointer;
    font-weight:900;
  }
  .cm-editable.editing{
    cursor:text;
  }
  .cm-editable input{
    border:1px solid var(--border);
    border-radius:8px;
    padding:4px 6px;
    font-size:13px;
    font-weight:800;
    width:160px;
  }
  .cm-edit-icon{
    display:inline-flex;
    align-items:center;
    justify-content:center;
    width:18px;
    height:18px;
    border:0;
    background:transparent;
    padding:0;
  }
  .cm-edit-icon svg{
    width:14px;
    height:14px;
    fill:var(--muted);
  }
  .cm-editable:hover .cm-edit-icon svg{
    fill:var(--text);
  }

  #global-loading-overlay{
    position:absolute;
    inset:0;
    background:transparent;
    display:flex;
    align-items:center;
    justify-content:center;
    z-index:20;
    opacity:0;
    pointer-events:none;
    transition:opacity .2s ease;
  }
  #global-loading-overlay.active{
    opacity:1;
    pointer-events:auto;
  }
  .global-loading-box{
    background:rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    color:var(--text);
    padding:18px 22px;
    border-radius:14px;
    border:1px solid var(--modal-border);
    box-shadow:0 8px 20px rgba(0,0,0,.12);
    display:flex;
    align-items:center;
    justify-content:center;
    margin:0 auto;
    min-width:200px;
    text-align:center;
    font-weight:800;
  }
  .global-loading-text{
    font-size:14px;
    line-height:1.4;
  }

  #toast-stack{
    position:fixed;
    right:16px;
    bottom:16px;
    display:flex;
    flex-direction:column;
    gap:10px;
    z-index:120;
    pointer-events:none;
  }
  .toast{
    min-width:220px;
    max-width:360px;
    background:#fff;
    border:1px solid var(--border);
    border-left:4px solid var(--danger);
    border-radius:12px;
    padding:10px 12px;
    box-shadow:0 10px 20px rgba(0,0,0,.12);
    display:flex;
    align-items:flex-start;
    gap:10px;
    opacity:0;
    transform:translateY(6px);
    transition:opacity .2s ease, transform .2s ease;
    pointer-events:auto;
  }
  .toast.show{
    opacity:1;
    transform:translateY(0);
  }
  .toast-icon{
    width:20px;
    height:20px;
    border-radius:50%;
    background:rgba(239,68,68,.12);
    color:var(--danger);
    font-weight:900;
    font-size:12px;
    display:flex;
    align-items:center;
    justify-content:center;
    flex:0 0 auto;
    margin-top:2px;
  }
  .toast-message{
    font-size:13px;
    line-height:1.4;
    font-weight:700;
    color:var(--text);
    flex:1 1 auto;
    word-break:keep-all;
  }
  .toast-close{
    border:0;
    background:transparent;
    color:var(--muted);
    font-weight:900;
    cursor:pointer;
    padding:0 2px;
    flex:0 0 auto;
  }
  .toast-close:hover{ color:var(--text); }

  #event-modal-overlay{
    position:fixed;
    inset:0;
    background:transparent;
    display:none;
    align-items:center;
    justify-content:center;
    padding:14px;
    z-index:70;
  }
  #event-modal-overlay.active{ display:flex; }
  #event-modal{
    width:min(520px, 96vw);
    background:rgba(255, 255, 255, 0.7);
    backdrop-filter: blur(12px);
    -webkit-backdrop-filter: blur(12px);
    box-shadow: var(--modal-shadow);
    border:1px solid var(--modal-border);
    border-radius:16px;
    padding:16px;
    display:flex;
    flex-direction:column;
    gap:16px;
  }
  .event-modal-head{
    display:flex;
    align-items:flex-start;
    justify-content:space-between;
    gap:10px;
  }
  .event-modal-title{
    font-size:18px;
    font-weight:900;
    margin-bottom:4px;
  }
  .event-modal-head button{
    border:0;
    background:transparent;
    cursor:pointer;
    font-size:20px;
  }
  .event-modal-body{
    display:flex;
    flex-direction:column;
    gap:12px;
  }
  .event-field{
    display:flex;
    flex-direction:column;
    gap:6px;
  }
  .event-field label{
    font-size:12px;
    font-weight:800;
    color:var(--muted);
  }
  .event-field input,
  .event-field textarea,
  .event-field select{
    border:1px solid var(--border);
    border-radius:10px;
    padding:8px;
    font-size:14px;
    font-family:inherit;
  }
  .event-field-row{
    display:flex;
    gap:8px;
    flex-wrap:wrap;
  }
  .event-modal-foot{
    display:flex;
    justify-content:flex-start;
    align-items:center;
    gap:10px;
  }
  .event-modal-actions{
    display:flex;
    gap:10px;
    margin-left:auto;
  }
  .event-modal-foot button{
    border-radius:10px;
    border:1px solid var(--border);
    background:#fff;
    font-weight:800;
    padding:6px 12px;
    cursor:pointer;
  }
  .event-modal-foot button.danger{
    border-color:rgba(239,68,68,.35);
    color:var(--danger);
    background:#fff;
  }
  .event-modal-foot button.primary{
    background:var(--text);
    color:#fff;
    border-color:var(--text);
  }
  .event-modal-foot button:hover:not(.primary){
    background:#f2f2f0;
  }
  .event-modal-foot button.danger:hover{
    background:rgba(239,68,68,.08);
  }

    /* Recent modal */
    #recent-overlay{
      position:fixed;
      inset:0;
      background:transparent;
      display:none;
      align-items:center;
      justify-content:center;
      padding:14px;
      z-index:65;
    }
    #recent-modal{
      width:min(560px, 100%);
      background:rgba(255, 255, 255, 0.7);
      backdrop-filter: blur(12px);
      -webkit-backdrop-filter: blur(12px);
      border:1px solid var(--modal-border);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0,0,0,.18);
      overflow:hidden;
    }
    .recent-head{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:14px;
      border-bottom:1px solid var(--modal-border);
    }
    .recent-title{ font-weight:900; font-size:14px; }
    .recent-body{
      max-height:60vh;
      overflow:auto;
      padding:10px 14px;
    }
    .recent-item{
      border:1px solid var(--modal-border);
      border-radius:12px;
      padding:10px;
      margin-bottom:8px;
      display:flex;
      align-items:flex-start;
      gap:10px;
      background:#fff;
    }
    .recent-item .badge{
      background:#eaf2ff;
      border-color:#d2e1ff;
      color:#1d3360;
    }
    .recent-main{ flex:1; min-width:0; }
    .recent-line1{
      font-weight:900;
      font-size:13px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .recent-line2{
      margin-top:3px;
      color:var(--muted);
      font-weight:800;
      font-size:12px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .recent-meta{
      margin-top:4px;
      color:var(--muted);
      font-weight:700;
      font-size:11px;
    }
    .recent-delete{
      border:1px solid var(--border);
      background:#fff;
      border-radius:10px;
      padding:6px 10px;
      font-weight:900;
      color:#8a1f1f;
      cursor:pointer;
      flex:0 0 auto;
    }
    .recent-delete:hover{
      background:#fdf2f2;
      border-color: rgba(239,68,68,.4);
    }
    .recent-foot{
      padding:12px 14px;
      border-top:1px solid var(--border);
      display:flex;
      justify-content:flex-end;
    }
    .recent-close{
      border:1px solid var(--border);
      border-radius:10px;
      padding:9px 12px;
      background:#fff;
      font-weight:900;
      cursor:pointer;
    }
    .recent-close:hover{ background:#f2f2f0; }

    button,
    .seg-toggle,
    .seg{
      border-radius:999px;
    }

    @media (max-width: 980px){
      .app{
        grid-template-columns: 1fr;
        gap:var(--block-vert-gap);
      }
      main{ padding-bottom:0; }
      aside{
        position:relative;
        top:auto;
        height:auto;
        padding-top:0;
        overflow:visible;
      }
      :root{ --sidebar-w: 1fr; }
    }
  </style>
</head>

<body>
<header>
  <div class="topbar">
    <div class="topbar-left">
      <div class="app-icon-slot" role="img" aria-label="앱 아이콘 자리"></div>
      <div class="divider"></div>

      <div class="ym-label" id="ym-label"></div>

      <div class="nav-group" role="group" aria-label="달력 이동">
        <button class="nav-btn is-circle" id="cal-prev" type="button" aria-label="이전"><span aria-hidden="true">←</span></button>
        <button class="nav-btn" id="cal-today" type="button"><span>오늘</span></button>
        <button class="nav-btn is-circle" id="cal-next" type="button" aria-label="다음"><span aria-hidden="true">→</span></button>
      </div>
    </div>

    <div class="topbar-right">
      <div class="event-search" role="search">
        <div class="event-search-field">
          <input type="text" id="event-search-input" placeholder="이벤트 검색" aria-label="이벤트 검색" />
          <button type="button" class="event-search-settings-btn" id="event-search-settings-btn" aria-label="검색 범위 설정">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M3 7h10v2H3V7zm0 8h14v2H3v-2zm14-8h4v2h-4V7zm-6 8h10v2H11v-2z"/>
            </svg>
          </button>
        </div>
        <button type="button" id="event-search-btn" aria-label="이벤트 검색">
          <svg viewBox="0 0 24 24" aria-hidden="true">
            <path d="M15.5 14h-.79l-.28-.27a6 6 0 1 0-.71.71l.27.28v.79L20 20.5 21.5 19 15.5 14zm-5.5 0a4 4 0 1 1 0-8 4 4 0 0 1 0 8z"/>
          </svg>
        </button>
        <div class="event-search-popover" id="event-search-popover" role="dialog" aria-label="검색 범위 설정">
          <div class="popover-title">검색 범위 설정</div>
          <button type="button" class="popover-close" id="event-search-range-close" aria-label="닫기">✕</button>
          <div class="popover-row">
            <span>이전</span>
            <input type="number" id="event-search-range-back" min="0" max="10" value="1" inputmode="numeric" />
            <span>년</span>
          </div>
          <div class="popover-row">
            <span>이후</span>
            <input type="number" id="event-search-range-forward" min="0" max="10" value="1" inputmode="numeric" />
            <span>년</span>
          </div>
          <div class="popover-actions">
            <button type="button" id="event-search-range-apply" aria-label="적용">✓</button>
          </div>
        </div>
      </div>
      <div class="view-switch" role="tablist" aria-label="뷰 전환">
        <span class="view-switch-indicator" aria-hidden="true"></span>
        <button class="view-btn" type="button" data-cal-view="year" id="cal-view-year"><span>년</span></button>
        <button class="view-btn active" type="button" data-cal-view="dayGridMonth" id="cal-view-month"><span>월</span></button>
        <button class="view-btn" type="button" data-cal-view="timeGridWeek" id="cal-view-week"><span>주</span></button>
        <button class="view-btn" type="button" data-cal-view="timeGridDay" id="cal-view-day"><span>일</span></button>
      </div>

      <button type="button" class="primary-btn icon-btn circle-btn" id="undo-last-btn" disabled aria-label="되돌리기" title="되돌리기">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M7.5 6.5V4L3 8.5l4.5 4.5V10.5h7.2c2.3 0 4.3 1.9 4.3 4.3 0 2.3-1.9 4.3-4.3 4.3H8.5v2h6.2c3.4 0 6.3-2.8 6.3-6.3 0-3.4-2.8-6.3-6.3-6.3H7.5z"/>
        </svg>
        <span class="icon-badge is-hidden" id="undo-count-badge" aria-hidden="true"></span>
      </button>
      <button class="header-btn icon-btn circle-btn" id="recent-added-btn" type="button" aria-label="최근 추가한 일정" title="최근 추가한 일정">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M12 4a8 8 0 1 1-5.66 2.34L4 4v6h6L7.88 7.88A6 6 0 1 0 12 6V4zm-1 4h2v5l3.5 2-1 1.73L11 14V8z"/>
        </svg>
      </button>
      <div class="header-actions">__HEADER_ACTIONS__</div>
      <button class="menu-btn" id="tool-menu-btn" type="button" aria-label="도구 열기">
        <svg viewBox="0 0 24 24" aria-hidden="true">
          <path d="M4 6h16v2H4V6zm0 5h16v2H4v-2zm0 5h16v2H4v-2z"/>
        </svg>
      </button>
    </div>
  </div>
</header>

<div class="app">
  <!-- Calendar LEFT -->
  <main>
    <div id="calendar-container">
      <div class="calendar-shell topbar-block" id="calendar-shell">
        <div class="month-label" id="month-label"></div>
        <div class="calendar-main-content">
          <div id="calendar"></div>
          <div id="events-main-slot">
            <div class="panel calendar-events-panel" id="events-list">
              <ul id="events-ul"></ul>
            </div>
          </div>
        </div>
        <div id="global-loading-overlay" aria-hidden="true">
          <div class="global-loading-box">
            <div class="global-loading-text">불러오는 중..</div>
          </div>
        </div>
      </div>
      <div id="year-view" aria-label="연간 달력">
        <div class="year-grid" id="year-grid"></div>
      </div>
    </div>
  </main>

  <!-- Utilities RIGHT -->
  <aside id="sidebar">
    <div id="events-side-slot" class="calendar-events-slot"></div>

    <div class="panel composer topbar-block">
      <div class="nlp-chat" id="nlp-chat"></div>
      <div class="composer-input-wrap">
        <div class="composer-left">
          <button type="button" class="attach-btn" id="nlp-attach-btn" aria-label="이미지 첨부">
            <svg viewBox="0 0 24 24" aria-hidden="true">
              <path d="M21 19a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2v14zm-2 0V5H5v14h14zM8.5 13.5l2.5 3 3.5-4.5 4.5 6H6l2.5-4.5zM9 8a2 2 0 1 0 0 4 2 2 0 0 0 0-4z"/>
            </svg>
          </button>

          <label class="seg-toggle" title="추가/삭제 전환">
            <input type="checkbox" id="nlp-mode-toggle"/>
            <span class="seg add" aria-label="추가">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 5c.55 0 1 .45 1 1v5h5c.55 0 1 .45 1 1s-.45 1-1 1h-5v5c0 .55-.45 1-1 1s-1-.45-1-1v-5H6c-.55 0-1-.45-1-1s.45-1 1-1h5V6c0-.55.45-1 1-1z"/>
              </svg>
            </span>
            <span class="seg del" aria-label="삭제">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M7 6h10l-1 14H8L7 6zm3-3h4l1 2H9l1-2zm-5 2h14v2H5V5z"/>
              </svg>
            </span>
          </label>
        </div>

        <textarea
          id="nlp-unified-text"
          placeholder="어떤 일정이든 입력하세요"
          rows="1"
        ></textarea>

        <div class="inline-action">
          <button
            type="button"
            id="nlp-action-btn"
            class="Btn mode-add scale-1"
            aria-label="문장으로 일정 추가/삭제"
            title="실행"
          >
            <div class="sign">
              <svg viewBox="0 0 24 24" aria-hidden="true">
                <path d="M12 5l6 6-1.4 1.4L13 8.8V20h-2V8.8L7.4 12.4 6 11l6-6z"/>
              </svg>
            </div>
          </button>

          <div class="loader-wrapper scale-0" id="nlp-unified-loader">
            <div class="loader"></div>
          </div>
        </div>
      </div>
      <input type="file" id="nlp-image-input" accept="image/*" multiple hidden>
      <div class="image-attachments" id="nlp-image-attachments"></div>

      <div class="scope-controls" id="delete-scope-controls">
        <div class="scope-title">삭제 범위 (최대 1년)</div>
        <div class="scope-row">
          <input type="date" id="delete-scope-start" aria-label="삭제 범위 시작">
          <span style="font-weight:900;">~</span>
          <input type="date" id="delete-scope-end" aria-label="삭제 범위 종료">
        </div>
      </div>

      <div class="reasoning-controls" id="reasoning-effort-control">
        <label for="reasoning-effort-select">추론 강도</label>
        <select id="reasoning-effort-select">
          <option value="low">낮음</option>
          <option value="medium">보통</option>
          <option value="high">높음</option>
        </select>
      </div>

    </div>

  </aside>
</div>

<div class="tool-overlay" id="tool-overlay" aria-hidden="true"></div>
<aside class="tool-drawer" id="tool-drawer" aria-hidden="true">
  <div class="tool-drawer-head">
    <div class="tool-drawer-title">도구</div>
    <button class="tool-close" id="tool-close-btn" type="button" aria-label="닫기">✕</button>
  </div>
  <div class="tool-drawer-body">
    <a class="tool-link" href="/settings">설정</a>
    <a class="tool-link" href="/logout">로그아웃</a>
  </div>
</aside>

<!-- Confirm Modal -->
<div id="confirm-overlay">
  <div id="confirm-modal" role="dialog" aria-modal="true">
    <div class="cm-head">
      <div>
        <div class="cm-title" id="confirm-title"></div>
        <div class="cm-desc" id="confirm-desc"></div>
      </div>
      <button class="cm-x" id="confirm-close" type="button">✕</button>
    </div>

    <div class="cm-body">
      <div id="confirm-list"></div>
    </div>

    <div class="cm-foot">
      <button class="cm-btn" id="confirm-cancel" type="button">취소</button>
      <button class="cm-btn primary" id="confirm-ok" type="button">적용</button>
    </div>
  </div>
</div>

<div id="event-modal-overlay">
  <div id="event-modal" role="dialog" aria-modal="true">
    <div class="event-modal-head">
      <div>
        <div class="event-modal-title" id="event-modal-title"></div>
        <div class="event-modal-sub" id="event-modal-sub"></div>
      </div>
      <button type="button" id="event-modal-close" aria-label="닫기">✕</button>
    </div>
    <div class="event-modal-body">
      <div class="event-field">
        <label for="event-modal-input-title">제목</label>
        <input type="text" id="event-modal-input-title" />
      </div>
      <div class="event-field">
        <label>시작</label>
        <div class="event-field-row">
          <input type="date" id="event-modal-input-start-date" />
          <input type="time" id="event-modal-input-start-time" />
        </div>
      </div>
      <div class="event-field">
        <label>종료</label>
        <div class="event-field-row">
          <input type="date" id="event-modal-input-end-date" />
          <input type="time" id="event-modal-input-end-time" />
        </div>
      </div>
      <div class="event-field">
        <label for="event-modal-input-location">장소</label>
        <input type="text" id="event-modal-input-location" />
      </div>
      <div class="event-field">
        <label for="event-modal-input-notes">메모</label>
        <textarea id="event-modal-input-notes" rows="2" placeholder="참고사항을 기록하세요"></textarea>
      </div>
    </div>
    <div class="event-modal-foot">
      <button type="button" class="danger" id="event-modal-delete">삭제</button>
      <div class="event-modal-actions">
        <button type="button" id="event-modal-cancel">취소</button>
        <button type="button" class="primary" id="event-modal-save">저장</button>
      </div>
    </div>
  </div>
</div>

<!-- Recent Added Modal -->
<div id="recent-overlay">
  <div id="recent-modal" role="dialog" aria-modal="true">
    <div class="recent-head">
      <div>
        <div class="recent-title">최근 추가한 일정</div>
        <div class="recent-meta" id="recent-desc">최근 14일 저장</div>
      </div>
      <button class="recent-close" id="recent-close" type="button">닫기</button>
    </div>
    <div class="recent-body" id="recent-list"></div>
    <div class="recent-foot">
      <button class="recent-close" id="recent-cancel" type="button">닫기</button>
    </div>
  </div>
</div>

<div id="image-editor-overlay" aria-hidden="true">
  <div class="image-editor-modal" role="dialog" aria-modal="true">
    <div class="image-editor-head">
      <div class="image-editor-title">이미지 가리기</div>
      <div class="image-editor-meta">드래그해서 검은 박스를 그려 민감한 정보를 가릴 수 있습니다.</div>
    </div>
    <div class="image-editor-canvas">
      <div class="image-editor-canvas-inner">
        <canvas id="image-editor-canvas"></canvas>
        <canvas id="image-editor-selection"></canvas>
      </div>
    </div>
    <div class="image-editor-foot">
      <button type="button" id="image-editor-undo">되돌리기</button>
      <div class="spacer"></div>
      <button type="button" id="image-editor-cancel">취소</button>
      <button type="button" class="primary" id="image-editor-apply">적용</button>
    </div>
  </div>
</div>
<div id="toast-stack" aria-live="polite" aria-atomic="true"></div>

<script>
  const apiBase = "/api";
  let calendar = null;
  let yearViewYear = null;
  let selectedDateStr = null; // YYYY-MM-DD
  let nlpInputComposing = false;

  let confirmState = { mode: null, addItems: [], deleteGroups: [] };
  const MS_PER_DAY = 24 * 60 * 60 * 1000;
  const APP_CONTEXT = window.__APP_CONTEXT__ || {};
  const APP_MODE = APP_CONTEXT.mode || "local";
  const IS_GOOGLE_MODE = APP_MODE === "google";
  const IS_ADMIN = !!APP_CONTEXT.admin;
  const REASONING_EFFORT_KEY = "calendar_reasoning_effort";
  const ALLOWED_REASONING_EFFORTS = ["low","medium","high"];
  const DEFAULT_REASONING_EFFORT = "low";
  let reasoningEffortValue = DEFAULT_REASONING_EFFORT;
  const undoStack = [];
  const MAX_IMAGE_ATTACHMENTS = 5;
  const MAX_IMAGE_DIMENSION = 1600;
  const MAX_IMAGE_BYTES = 2.5 * 1024 * 1024;
  const nlpImageAttachments = [];
  const nlpConversation = [];
  let imageAttachmentSeq = 1;
  let imageEditorCanvas = null;
  let imageEditorCtx = null;
  let imageEditorOverlay = null;
  let imageEditorSelection = null;
  let imageEditorSelectionCtx = null;
  let imageEditorUndoStack = [];
  const imageEditorState = {
    attachmentId: null,
    drawing: false,
    startX: 0,
    startY: 0,
    pointerId: null
  };
  let currentEventModalContext = null;
  const googleEventCache = {};
  const googleEventFetches = {};
  let googleCacheDirty = false;
  let googleCacheGeneration = 0;
  let googleGlobalLoaderDepth = 0;
  const recurrenceEndSelections = new Map();
  const localEventsCache = { start: null, end: null, items: [] };
  let localCacheDirty = true;
  let localCachePromise = null;
  let initialListLoaded = false;
  let toastSeq = 0;
  const eventsDockQuery = window.matchMedia("(min-width: 981px)");

  function syncEventsPanelDock(){
    const panel = document.getElementById("events-list");
    const mainSlot = document.getElementById("events-main-slot");
    const sideSlot = document.getElementById("events-side-slot");
    if(!panel || !mainSlot || !sideSlot) return;
    const isDetached = eventsDockQuery.matches;
    const target = isDetached ? sideSlot : mainSlot;
    if(panel.parentElement !== target){
      target.appendChild(panel);
    }
    panel.classList.toggle("topbar-block", isDetached);
    panel.classList.toggle("is-detached", isDetached);
    sideSlot.classList.toggle("has-events", isDetached);
  }

  function initEventsPanelDock(){
    syncEventsPanelDock();
    if(typeof eventsDockQuery.addEventListener === "function"){
      eventsDockQuery.addEventListener("change", syncEventsPanelDock);
    }else if(typeof eventsDockQuery.addListener === "function"){
      eventsDockQuery.addListener(syncEventsPanelDock);
    }
  }

  function showToast(message, kind = "warn", durationMs = 3600){
    const text = (message || "").toString().trim();
    if(!text) return;
    const host = document.getElementById("toast-stack");
    if(!host) return;

    toastSeq += 1;
    const toast = document.createElement("div");
    toast.className = `toast ${kind}`;
    toast.setAttribute("role", "status");
    toast.dataset.toastId = String(toastSeq);

    const icon = document.createElement("div");
    icon.className = "toast-icon";
    icon.textContent = "!";

    const msg = document.createElement("div");
    msg.className = "toast-message";
    msg.textContent = text;

    const close = document.createElement("button");
    close.type = "button";
    close.className = "toast-close";
    close.setAttribute("aria-label", "닫기");
    close.textContent = "닫기";

    toast.appendChild(icon);
    toast.appendChild(msg);
    toast.appendChild(close);
    host.appendChild(toast);

    const dismiss = () => {
      toast.classList.remove("show");
      const remove = () => toast.remove();
      toast.addEventListener("transitionend", remove, { once: true });
      setTimeout(remove, 350);
    };

    const timer = setTimeout(dismiss, durationMs);
    close.addEventListener("click", () => {
      clearTimeout(timer);
      dismiss();
    });

    requestAnimationFrame(() => toast.classList.add("show"));
  }

  function showWarning(message){
    showToast(message, "warn");
  }

  function buildEventsFetchUrl(startDate, endDate){
    const params = new URLSearchParams();
    if(startDate){
      params.append("start_date", startDate);
    }
    if(endDate){
      params.append("end_date", endDate);
    }
    const query = params.toString();
    return query ? `${apiBase}/events?${query}` : `${apiBase}/events`;
  }

  async function fetchLocalEventsBetween(startDate, endDate){
    const url = buildEventsFetchUrl(startDate, endDate);
    const res = await fetch(url);
    if(!res.ok){
      throw new Error("local events failed");
    }
    const data = await res.json();
    return Array.isArray(data) ? data : [];
  }

  function markLocalCacheDirty(){
    localCacheDirty = true;
  }

  function cacheCoversRange(cache, startDate, endDate){
    return !!cache.start && !!cache.end && startDate >= cache.start && endDate <= cache.end;
  }

  function filterEventsInRange(items, startDate, endDate){
    return (items || []).filter(ev => eventIntersectsRange(ev, startDate, endDate));
  }

  async function getLocalEventsForRange(startDate, endDate){
    if(!startDate || !endDate) return [];
    if(!localCacheDirty && cacheCoversRange(localEventsCache, startDate, endDate)){
      return filterEventsInRange(localEventsCache.items, startDate, endDate);
    }
    if(localCachePromise){
      try{
        await localCachePromise;
      }catch(err){
        // ignore, fallback to fetching below
      }
      if(!localCacheDirty && cacheCoversRange(localEventsCache, startDate, endDate)){
        return filterEventsInRange(localEventsCache.items, startDate, endDate);
      }
    }
    localCachePromise = (async () => {
      const data = await fetchLocalEventsBetween(startDate, endDate);
      localEventsCache.start = startDate;
      localEventsCache.end = endDate;
      localEventsCache.items = Array.isArray(data) ? data : [];
      localCacheDirty = false;
      return localEventsCache.items;
    })().catch((err) => {
      localCacheDirty = true;
      throw err;
    }).finally(() => {
      localCachePromise = null;
    });
    const data = await localCachePromise;
    return filterEventsInRange(data, startDate, endDate);
  }

  function validateDateRange(start, end){
    if(!start || !end){
      return { ok:false, message:"시작·종료 날짜를 모두 선택해주세요." };
    }
    const startMs = Date.parse(start);
    const endMs = Date.parse(end);
    if(Number.isNaN(startMs) || Number.isNaN(endMs)){
      return { ok:false, message:"날짜 형식이 잘못되었습니다." };
    }
    if(endMs < startMs){
      return { ok:false, message:"종료 날짜가 시작 날짜보다 빠릅니다." };
    }
    const diffDays = Math.floor((endMs - startMs) / MS_PER_DAY);
    if(diffDays > 365){
      return { ok:false, message:"범위는 최대 1년까지만 설정할 수 있습니다." };
    }
    return { ok:true };
  }

  function getDeleteScopeOrAlert(){
    const startInput = document.getElementById("delete-scope-start");
    const endInput = document.getElementById("delete-scope-end");
    const start = startInput?.value || "";
    const end = endInput?.value || "";
    const validation = validateDateRange(start, end);
    if(!validation.ok){
      showWarning(validation.message);
      return null;
    }
    return { start, end };
  }

  function setDefaultDateRange(startId, endId, spanDays){
    const startInput = document.getElementById(startId);
    const endInput = document.getElementById(endId);
    if(!startInput || !endInput) return;
    if(startInput.value && endInput.value) return;
    const startDate = new Date();
    const endDate = new Date(startDate.getTime() + spanDays * MS_PER_DAY);
    const fmt = (dt) => dt.toISOString().slice(0,10);
    if(!startInput.value){
      startInput.value = fmt(startDate);
    }
    if(!endInput.value){
      endInput.value = fmt(endDate);
    }
  }

  function toDateStrLocal(d){
    const y = d.getFullYear();
    const m = String(d.getMonth()+1).padStart(2,"0");
    const day = String(d.getDate()).padStart(2,"0");
    return `${y}-${m}-${day}`;
  }

  function normalizeSearchQuery(raw){
    return (raw || "").trim().toLowerCase();
  }

  function getEventDateStr(ev){
    return toDateOnly(ev?.start) || toDateOnly(ev?.end) || "";
  }

  function eventMatchesQuery(ev, query){
    if(!ev || !query) return false;
    const title = (ev.title || "").toString().toLowerCase();
    const location = (ev.location || "").toString().toLowerCase();
    return title.includes(query) || location.includes(query);
  }

  function extractSearchYears(query, baseYear){
    const years = new Set();
    if(Number.isFinite(baseYear)){
      for(let y = baseYear - 1; y <= baseYear + 1; y += 1){
        if(y >= 1970 && y <= 2100){
          years.add(y);
        }
      }
    }
    const matches = (query || "").match(/\b(19|20)\d{2}\b/g) || [];
    matches.forEach((val) => {
      const y = parseInt(val, 10);
      if(Number.isFinite(y) && y >= 1970 && y <= 2100){
        years.add(y);
      }
    });
    return Array.from(years);
  }

  function getYearsFromRange(startDateStr, endDateStr){
    const startYear = getYearFromDateStr(startDateStr);
    const endYear = getYearFromDateStr(endDateStr);
    if(!Number.isFinite(startYear) || !Number.isFinite(endYear)){
      return [];
    }
    const years = [];
    for(let y = startYear; y <= endYear; y += 1){
      years.push(y);
    }
    return years;
  }

  function getCustomSearchRange(backYears, forwardYears){
    const back = Number.isFinite(backYears) ? backYears : 0;
    const forward = Number.isFinite(forwardYears) ? forwardYears : 0;
    if(back <= 0 && forward <= 0){
      return null;
    }
    const today = new Date();
    const start = new Date(today);
    const end = new Date(today);
    start.setFullYear(today.getFullYear() - Math.max(0, back));
    end.setFullYear(today.getFullYear() + Math.max(0, forward));
    return {
      start: toDateStrLocal(start),
      end: toDateStrLocal(end)
    };
  }

  function pickBestMatch(matches){
    if(!Array.isArray(matches) || matches.length === 0){
      return null;
    }
    const today = toDateStrLocal(new Date());
    const dated = matches
      .map((ev) => ({ ev, date: getEventDateStr(ev) }))
      .filter((item) => item.date);
    if(dated.length === 0){
      return matches[0];
    }
    const upcoming = dated
      .filter((item) => item.date >= today)
      .sort((a, b) => a.date.localeCompare(b.date));
    if(upcoming.length > 0){
      return upcoming[0].ev;
    }
    dated.sort((a, b) => b.date.localeCompare(a.date));
    return dated[0].ev;
  }

  function getCalendarViewRange(info){
    const startSource = (info && info.start) ? info.start : new Date();
    const startDate = new Date(startSource);
    const endSource = (info && info.end) ? info.end : startDate;
    let endDate = new Date(endSource);
    endDate = new Date(endDate.getTime() - MS_PER_DAY);
    if(endDate < startDate){
      endDate = new Date(startDate);
    }
    const diffDays = Math.floor((endDate.getTime() - startDate.getTime()) / MS_PER_DAY);
    if(diffDays > 365){
      endDate = new Date(startDate.getTime() + 365 * MS_PER_DAY);
    }
    return {
      startDate,
      endDate,
      startStr: toDateStrLocal(startDate),
      endStr: toDateStrLocal(endDate)
    };
  }

  function updateYearMonthLabel(date){
    const ymLabel = document.getElementById("ym-label");
    const monthLabel = document.getElementById("month-label");
    const y = date.getFullYear();
    const m = date.getMonth() + 1;
    ymLabel.textContent = `${y}`;
    if(monthLabel){
      monthLabel.textContent = `${m}`;
    }
  }

  function setYearViewVisible(isVisible, targetView = "dayGridMonth"){
    const container = document.getElementById("calendar-container");
    const yearView = document.getElementById("year-view");
    if(!container || !yearView) return;

    container.classList.toggle("is-year-view", !!isVisible);
    yearView.classList.toggle("active", !!isVisible);
    yearView.classList.toggle("is-visible", !!isVisible);

    if(!isVisible && calendar){
      requestAnimationFrame(() => calendar.updateSize());
    }
  }

  function refreshYearView(year){
    if(!Number.isFinite(year)) return;
    yearViewYear = year;
    const ymLabel = document.getElementById("ym-label");
    if(ymLabel) ymLabel.textContent = `${yearViewYear}`;
    renderYearView(yearViewYear);
  }

  function renderYearView(year){
    const grid = document.getElementById("year-grid");
    if(!grid || !Number.isFinite(year)) return;
    grid.innerHTML = "";
    const today = new Date();
    const todayKey = toDateStrLocal(today);
    const weekdays = ["일", "월", "화", "수", "목", "금", "토"];

    for(let month = 0; month < 12; month += 1){
      const card = document.createElement("button");
      card.type = "button";
      card.className = "year-card";
      card.setAttribute("aria-label", `${month + 1}월`);
      card.dataset.month = String(month + 1);
      card.dataset.year = String(year);

      const title = document.createElement("div");
      title.className = "year-card-title";
      title.textContent = `${month + 1}`;
      card.appendChild(title);

      const head = document.createElement("div");
      head.className = "mini-weekdays";
      weekdays.forEach((label) => {
        const span = document.createElement("span");
        span.textContent = label;
        head.appendChild(span);
      });
      card.appendChild(head);

      const daysWrap = document.createElement("div");
      daysWrap.className = "mini-days";
      const first = new Date(year, month, 1);
      const startDay = first.getDay();
      const daysInMonth = new Date(year, month + 1, 0).getDate();
      for(let i = 0; i < startDay; i += 1){
        const empty = document.createElement("span");
        empty.className = "mini-day is-empty";
        empty.textContent = ".";
        daysWrap.appendChild(empty);
      }
      for(let d = 1; d <= daysInMonth; d += 1){
        const mm = String(month + 1).padStart(2, "0");
        const dd = String(d).padStart(2, "0");
        const dateStr = `${year}-${mm}-${dd}`;
        const dayEl = document.createElement("span");
        dayEl.className = "mini-day";
        dayEl.textContent = String(d);
        if(dateStr === todayKey){
          dayEl.classList.add("is-today");
        }
        daysWrap.appendChild(dayEl);
      }
      card.appendChild(daysWrap);

      card.addEventListener("click", () => {
        const mm = String(month + 1).padStart(2, "0");
        const targetDate = `${year}-${mm}-01`;
        calendar.changeView("dayGridMonth");
        calendar.gotoDate(targetDate);
        setActiveView("dayGridMonth");
        setSelectedDate(targetDate);
        loadEventListForDate(targetDate);
        setYearViewVisible(false, "dayGridMonth");
      });

      grid.appendChild(card);
    }
  }

  function setActiveView(viewType){
    document.querySelectorAll("[data-cal-view]").forEach(btn => {
      btn.classList.toggle("active", btn.dataset.calView === viewType);
    });
    requestAnimationFrame(updateViewSwitchIndicators);
  }

  function updateViewSwitchIndicators(){
    document.querySelectorAll(".view-switch").forEach((wrap) => {
      const indicator = wrap.querySelector(".view-switch-indicator");
      const activeBtn = wrap.querySelector(".view-btn.active") || wrap.querySelector(".view-btn");
      if(!indicator || !activeBtn) return;
      if(wrap.offsetWidth === 0 || wrap.offsetHeight === 0) return;
      const x = activeBtn.offsetLeft;
      const y = activeBtn.offsetTop;
      indicator.style.width = `${activeBtn.offsetWidth}px`;
      indicator.style.height = `${activeBtn.offsetHeight}px`;
      indicator.style.transform = `translate3d(${x}px, ${y}px, 0)`;
    });
  }

  function setSelectedDate(dateStr){
    selectedDateStr = dateStr;
    if(calendar){
      syncSelectedDayHighlight();
    }
  }

  function syncSelectedDayHighlight(){
    const target = selectedDateStr;
    if(!target){
      return;
    }
    requestAnimationFrame(() => {
      document.querySelectorAll("#calendar .fc-daygrid-day[data-date]").forEach(cell => {
        cell.classList.toggle("selected-day", cell.getAttribute("data-date") === target);
      });
      document.querySelectorAll("#calendar .fc-col-header-cell[data-date]").forEach(cell => {
        cell.classList.toggle("selected-day-header", cell.getAttribute("data-date") === target);
      });
      document.querySelectorAll("#calendar .fc-timegrid-col[data-date]").forEach(col => {
        col.classList.toggle("selected-day", col.getAttribute("data-date") === target);
      });
    });
  }

  function formatCreatedAt(ts){
    if(!ts) return "";
    try{
      const [d,t] = ts.split("T");
      const [y,m,da] = d.split("-").map(x => parseInt(x,10));
      const [hh,mm] = (t || "00:00").split(":").map(x => parseInt(x,10));
      const dt = new Date(Date.UTC(y, (m||1)-1, da||1, hh||0, mm||0));
      return new Intl.DateTimeFormat("ko-KR", {
        month:"2-digit", day:"2-digit",
        hour:"2-digit", minute:"2-digit",
        hour12:false, timeZone:"Asia/Seoul"
      }).format(dt);
    }catch{
      return ts;
    }
  }

  function setupShadowAutoGrow(textareaId){
    const ta = document.getElementById(textareaId);
    if(!ta) return;

    const wrap = ta.closest(".composer-input-wrap");
    const shadow = document.createElement("div");
    shadow.setAttribute("aria-hidden", "true");
    shadow.style.position = "absolute";
    shadow.style.top = "0";
    shadow.style.left = "-9999px";
    shadow.style.visibility = "hidden";
    shadow.style.pointerEvents = "none";
    shadow.style.whiteSpace = "pre-wrap";
    shadow.style.wordBreak = "break-word";
    shadow.style.overflowWrap = "break-word";
    shadow.style.padding = "0";
    shadow.style.margin = "0";
    shadow.style.border = "0";
    shadow.style.boxSizing = "border-box";
    document.body.appendChild(shadow);
    let base = 28;
    let rafId = null;
    let shadowPadY = 0;
    let shadowLineHeight = 0;

    const syncShadowStyle = () => {
      const cs = getComputedStyle(ta);
      shadow.style.fontFamily = cs.fontFamily;
      shadow.style.fontSize = cs.fontSize;
      shadow.style.fontWeight = cs.fontWeight;
      shadow.style.letterSpacing = cs.letterSpacing;
      const fs = parseFloat(cs.fontSize) || 14;
      const lh = parseFloat(cs.lineHeight);
      shadowLineHeight = Number.isFinite(lh) ? lh : fs * 1.45;
      shadow.style.lineHeight = `${shadowLineHeight}px`;
      const padTop = parseFloat(cs.paddingTop) || 0;
      const padRight = parseFloat(cs.paddingRight) || 0;
      const padBottom = parseFloat(cs.paddingBottom) || 0;
      const padLeft = parseFloat(cs.paddingLeft) || 0;
      shadowPadY = padTop + padBottom;
      shadow.style.paddingTop = `${padTop}px`;
      shadow.style.paddingRight = `${padRight}px`;
      shadow.style.paddingBottom = `${padBottom}px`;
      shadow.style.paddingLeft = `${padLeft}px`;
    };

    const getLineHeight = () => {
      if(shadowLineHeight) return shadowLineHeight;
      const cs = getComputedStyle(ta);
      const lh = parseFloat(cs.lineHeight);
      if(Number.isFinite(lh)) return lh;
      const fs = parseFloat(cs.fontSize) || 14;
      return fs * 1.45;
    };

    const getInlineWidth = () => {
      if(!wrap) return ta.clientWidth;
      const style = getComputedStyle(wrap);
      const padLeft = parseFloat(style.paddingLeft) || 0;
      const padRight = parseFloat(style.paddingRight) || 0;
      const gap = parseFloat(style.getPropertyValue("--composer-gap")) || 8;
      const left = wrap.querySelector(".composer-left");
      const action = wrap.querySelector(".inline-action");
      const leftW = left ? left.offsetWidth : 0;
      const actionW = action ? action.offsetWidth : 0;
      let gaps = 0;
      if(leftW && actionW) gaps = gap * 2;
      else if(leftW || actionW) gaps = gap;
      const width = wrap.clientWidth - padLeft - padRight - leftW - actionW - gaps;
      return Math.max(Math.floor(width), 0);
    };

    const measureInline = (value) => {
      syncShadowStyle();
      const lineHeight = getLineHeight();
      if(!wrap){
        return { inlineHeight: base, lineHeight };
      }
      const width = getInlineWidth();
      if(width <= 0){
        return { inlineHeight: base, lineHeight };
      }
      shadow.style.width = `${width}px`;
      shadow.textContent = value || "";
      const totalHeight = Math.ceil(shadow.scrollHeight || 0);
      const inlineHeight = Math.max(0, totalHeight - shadowPadY);
      return { inlineHeight, lineHeight };
    };

    const shouldUseMultiline = (value, metrics) => {
      const text = value || "";
      if(text.includes("\n")) return true;
      if(text.trim() === "") return false;
      if(!wrap) return false;
      const lineHeight = metrics?.lineHeight || getLineHeight();
      const measuredHeight = metrics?.inlineHeight || 0;
      const lineCount = Math.max(1, Math.ceil(measuredHeight / lineHeight));
      return lineCount >= 2;
    };

    const updateWrap = (value, metrics) => {
      if(!wrap) return;
      const nextIsMultiline = shouldUseMultiline(value, metrics);
      const currentIsMultiline = wrap.classList.contains("is-multiline");
      if(currentIsMultiline === nextIsMultiline) return;

      const targets = [
        wrap.querySelector(".composer-left"),
        ta,
        wrap.querySelector(".inline-action")
      ].filter(Boolean);

      const firstRects = targets.map(el => el.getBoundingClientRect());
      wrap.classList.toggle("is-multiline", nextIsMultiline);
      const lastRects = targets.map(el => el.getBoundingClientRect());

      targets.forEach((el, idx) => {
        const first = firstRects[idx];
        const last = lastRects[idx];
        const dx = first.left - last.left;
        const dy = first.top - last.top;
        if(!dx && !dy) return;

        if(el.getAnimations){
          el.getAnimations().forEach(anim => anim.cancel());
        }
        const keyframes = [
          { transform: `translate(${dx}px, ${dy}px)` },
          { transform: "translate(0, 0)" }
        ];
        if(el !== ta){
          keyframes[0].opacity = 0.35;
          keyframes[1].opacity = 1;
        }
        el.animate(keyframes, {
          duration:240,
          easing:"cubic-bezier(.22,.61,.36,1)",
          fill:"both"
        });
      });
    };

    const computeBase = () => {
      const prev = ta.value;
      ta.value = "";
      ta.style.height = "auto";
      const measured = ta.scrollHeight;
      base = Math.max(measured || 0, 28);
      ta.value = prev;
    };

    const resize = () => {
      const value = ta.value ?? "";
      if(value.trim() === ""){
        if(rafId) cancelAnimationFrame(rafId);
        updateWrap("", { inlineHeight: base, lineHeight: getLineHeight() });
        ta.style.height = base + "px";
        return;
      }

      const metrics = measureInline(value);
      updateWrap(value, metrics);
      const startH = ta.getBoundingClientRect().height;
      ta.style.height = "auto";
      const actualHeight = ta.scrollHeight;
      const inlineHeight = Math.max(metrics.inlineHeight || 0, base);
      let target = Math.max(actualHeight, inlineHeight, base);

      if(target <= base + 1){ target = base; }
      ta.style.height = startH + "px";

      if(rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        ta.style.height = target + "px";
      });
    };

    requestAnimationFrame(() => {
      computeBase();
      ta.style.height = base + "px";
      resize();
    });

    ["input","focus"].forEach(evt => ta.addEventListener(evt, resize));
    const onResize = () => {
      if(rafId) cancelAnimationFrame(rafId);
      rafId = requestAnimationFrame(() => {
        syncShadowStyle();
        computeBase();
        const metrics = measureInline(ta.value || "");
        updateWrap(ta.value || "", metrics);
        resize();
      });
    };
    window.addEventListener("resize", onResize);
  }

  function toDateOnly(value){
    if(!value || value.length < 10) return null;
    return value.slice(0,10);
  }

  function addDaysToDateStr(dateStr, days){
    if(!dateStr) return null;
    const parts = dateStr.split("-").map(part => parseInt(part, 10));
    if(parts.length !== 3 || parts.some(n => Number.isNaN(n))) return null;
    const [y, m, d] = parts;
    const dt = new Date(Date.UTC(y, m - 1, d));
    dt.setUTCDate(dt.getUTCDate() + days);
    const yy = dt.getUTCFullYear();
    const mm = String(dt.getUTCMonth() + 1).padStart(2,"0");
    const dd = String(dt.getUTCDate()).padStart(2,"0");
    return `${yy}-${mm}-${dd}`;
  }

  function getEventDateSpan(ev){
    if(!ev) return null;
    const startDate = toDateOnly(ev.start) || toDateOnly(ev.end);
    if(!startDate) return null;
    let endDate = toDateOnly(ev.end) || startDate;
    if((ev.allDay === true || ev.all_day === true) && ev.end && typeof ev.end === "string" && ev.end.endsWith("T00:00")){
      const adjusted = addDaysToDateStr(endDate, -1);
      if(adjusted) endDate = adjusted;
    }
    if(endDate < startDate){
      endDate = startDate;
    }
    return { start: startDate, end: endDate };
  }

  function eventCoversDate(ev, dateStr){
    if(!ev || !dateStr) return false;
    const span = getEventDateSpan(ev);
    if(!span) return false;
    return dateStr >= span.start && dateStr <= span.end;
  }

  function eventIntersectsRange(ev, startDateStr, endDateStr){
    const span = getEventDateSpan(ev);
    if(!span || !startDateStr || !endDateStr) return false;
    if(span.end < startDateStr) return false;
    if(span.start > endDateStr) return false;
    return true;
  }

  function isAllDayRange(start, end){
    if(!start) return false;
    const startDate = toDateOnly(start);
    if(!startDate) return false;
    const startTime = start.length >= 16 ? start.slice(11,16) : "00:00";
    if(startTime !== "00:00") return false;
    if(!end){
      return true;
    }
    const endDate = toDateOnly(end);
    if(!endDate) return true;
    const endTime = end.length >= 16 ? end.slice(11,16) : "23:59";
    if(endDate < startDate) return false;
    if(endTime === "00:00"){
      return endDate > startDate;
    }
    return endTime === "23:59" || endTime === "00:00";
  }

  function fmtRange(start, end, allDayOverride){
    if(!start) return "";
    const startDate = toDateOnly(start);
    const isAllDay = (typeof allDayOverride === "boolean")
      ? allDayOverride
      : isAllDayRange(start, end);
    if(isAllDay){
      const endDate = toDateOnly(end);
      if(endDate && startDate && endDate !== startDate){
        return `${startDate}~${endDate} 하루종일`;
      }
      return `${startDate || ""} 하루종일`;
    }
    const st = start.slice(11,16);
    if(end) return `${startDate || ""} ${st}–${end.slice(11,16)}`;
    return `${startDate || ""} ${st}`;
  }

  function formatEventMeta(ev){
    if(!ev) return "";
    const startStr = ev.start || "";
    const endStr = ev.end || null;
    const isAllDay = (ev.all_day === true) || isAllDayRange(startStr, endStr);
    if(isAllDay){
      const startDate = toDateOnly(startStr);
      const endDate = toDateOnly(endStr);
      let label = "하루종일";
      if(startDate && endDate && startDate !== endDate){
        label = `하루종일 · ${startDate}~${endDate}`;
      }
      return ev.location ? `${label} · ${ev.location}` : label;
    }
    const timePart = startStr.length >= 16 ? startStr.slice(11,16) : "";
    const label = timePart ? `시작 ${timePart}` : "시간 없음";
    return ev.location ? `${label} · ${ev.location}` : label;
  }

  function closeEventModal(){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    overlay.classList.remove("active");
    overlay.style.display = "none";
    currentEventModalContext = null;
  }

  function setEventModalDeleteVisible(isVisible){
    const deleteBtn = document.getElementById("event-modal-delete");
    if(!deleteBtn) return;
    deleteBtn.style.display = isVisible ? "inline-flex" : "none";
  }

  function openEventModal(eventInfo){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    const titleEl = document.getElementById("event-modal-title");
    const subEl = document.getElementById("event-modal-sub");
    const titleInput = document.getElementById("event-modal-input-title");
    const startDateInput = document.getElementById("event-modal-input-start-date");
    const startTimeInput = document.getElementById("event-modal-input-start-time");
    const endDateInput = document.getElementById("event-modal-input-end-date");
    const endTimeInput = document.getElementById("event-modal-input-end-time");
    const locationInput = document.getElementById("event-modal-input-location");
    const notesInput = document.getElementById("event-modal-input-notes");
    if(!titleInput || !startDateInput || !startTimeInput || !endDateInput || !endTimeInput || !locationInput || !notesInput){
      return;
    }

    const toLocalDate = (value) => {
      if(!value) return "";
      const dt = new Date(value);
      if(Number.isNaN(dt.getTime())){
        return (value || "").slice(0, 10);
      }
      const offset = dt.getTimezoneOffset();
      const adjusted = new Date(dt.getTime() - offset * 60 * 1000);
      return adjusted.toISOString().slice(0, 10);
    };

    const toLocalTime = (value) => {
      if(!value) return "";
      const dt = new Date(value);
      if(Number.isNaN(dt.getTime())) return "";
      return dt.toTimeString().slice(0, 5);
    };

    titleEl.textContent = eventInfo.title || "(제목 없음)";
    subEl.textContent = (eventInfo.source === "google") ? "Google 일정" : "내 일정";
    titleInput.value = eventInfo.title || "";
    startDateInput.value = toLocalDate(eventInfo.start);
    startTimeInput.value = eventInfo.allDay ? "" : toLocalTime(eventInfo.start);
    endDateInput.value = toLocalDate(eventInfo.end);
    endTimeInput.value = eventInfo.allDay ? "" : toLocalTime(eventInfo.end);
    locationInput.value = eventInfo.location || "";
    notesInput.value = eventInfo.notes || "";

    const numericId = parseInt(eventInfo.id, 10);
    currentEventModalContext = {
      source: eventInfo.source || "local",
      localId: (eventInfo.source === "google") ? null : (Number.isFinite(numericId) ? numericId : null),
      googleId: eventInfo.googleId || null,
      isNew: false
    };

    setEventModalDeleteVisible(true);
    overlay.style.display = "flex";
    requestAnimationFrame(() => overlay.classList.add("active"));
  }

  function openCreateEventModal(dateStr){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    const titleEl = document.getElementById("event-modal-title");
    const subEl = document.getElementById("event-modal-sub");
    const titleInput = document.getElementById("event-modal-input-title");
    const startDateInput = document.getElementById("event-modal-input-start-date");
    const startTimeInput = document.getElementById("event-modal-input-start-time");
    const endDateInput = document.getElementById("event-modal-input-end-date");
    const endTimeInput = document.getElementById("event-modal-input-end-time");
    const locationInput = document.getElementById("event-modal-input-location");
    const notesInput = document.getElementById("event-modal-input-notes");
    if(!titleInput || !startDateInput || !startTimeInput || !endDateInput || !endTimeInput || !locationInput || !notesInput){
      return;
    }

    titleEl.textContent = "새 일정";
    subEl.textContent = IS_GOOGLE_MODE ? "Google 일정" : "내 일정";
    titleInput.value = "";
    startDateInput.value = dateStr || "";
    startTimeInput.value = "";
    endDateInput.value = dateStr || "";
    endTimeInput.value = "";
    locationInput.value = "";
    notesInput.value = "";

    currentEventModalContext = {
      source: IS_GOOGLE_MODE ? "google" : "local",
      localId: null,
      googleId: null,
      isNew: true
    };

    setEventModalDeleteVisible(false);
    overlay.style.display = "flex";
    requestAnimationFrame(() => overlay.classList.add("active"));
    titleInput.focus();
  }

  async function saveEventModal(){
    if(!currentEventModalContext) return;
    const titleInput = document.getElementById("event-modal-input-title");
    const startDateInput = document.getElementById("event-modal-input-start-date");
    const startTimeInput = document.getElementById("event-modal-input-start-time");
    const endDateInput = document.getElementById("event-modal-input-end-date");
    const endTimeInput = document.getElementById("event-modal-input-end-time");
    const locationInput = document.getElementById("event-modal-input-location");
    const notesInput = document.getElementById("event-modal-input-notes");
    if(!titleInput || !startDateInput || !startTimeInput || !endDateInput || !endTimeInput || !locationInput || !notesInput){
      return;
    }

    const title = titleInput.value.trim();
    const startDate = startDateInput.value;
    const startTime = startTimeInput.value;
    const endDate = endDateInput.value;
    const endTime = endTimeInput.value;
    const locationValue = locationInput.value.trim();

    if(!title){
      showWarning("제목을 입력해주세요.");
      return;
    }
    if(!startDate){
      showWarning("시작 날짜를 입력해주세요.");
      return;
    }

    const combineDateTime = (dateVal, timeVal) => {
      if(!dateVal) return "";
      if(!timeVal) return `${dateVal}T00:00`;
      return `${dateVal}T${timeVal}`;
    };

    const payload = {
      title,
      start: combineDateTime(startDate, startTime),
      end: endDate ? combineDateTime(endDate, endTime || "00:00") : null,
      location: locationValue || null,
      all_day: !startTime && !endTime
    };

    if(payload.end){
      const startMs = Date.parse(payload.start);
      const endMs = Date.parse(payload.end);
      if(!Number.isNaN(startMs) && !Number.isNaN(endMs) && endMs < startMs){
        showWarning("종료 시각이 시작 시각보다 빠릅니다.");
        return;
      }
    }

    const headers = { "Content-Type": "application/json" };
    let touchedGoogleEvent = false;
    try{
      const isNew = !!currentEventModalContext.isNew
        || (!currentEventModalContext.localId && !currentEventModalContext.googleId);
      if(isNew){
        const res = await fetch("/api/events", {
          method:"POST",
          headers,
          body: JSON.stringify(payload)
        });
        if(!res.ok){
          showWarning("일정 추가에 실패했습니다.");
          return;
        }
        const created = await res.json();
        recordUndoBatch([created]);
        markLocalCacheDirty();
        if(IS_GOOGLE_MODE){
          markGoogleCacheDirty();
        }
        closeEventModal();
        await refreshAll();
        return;
      }
      if(currentEventModalContext.source === "google"){
        const googleId = currentEventModalContext.googleId || "";
        if(googleId){
          await fetch(`/api/google/events/${encodeURIComponent(googleId)}`, {
            method:"PATCH",
            headers,
            body: JSON.stringify(payload)
          });
          touchedGoogleEvent = true;
        }
      }else{
        const localId = currentEventModalContext.localId;
        if(localId){
          await fetch(`/api/events/${localId}`, {
            method:"PATCH",
            headers,
            body: JSON.stringify(payload)
          });
          markLocalCacheDirty();
        }
      }
      if(touchedGoogleEvent){
        markGoogleCacheDirty();
      }
      closeEventModal();
      await refreshAll();
    }catch(err){
      console.error(err);
      showWarning("일정 수정에 실패했습니다.");
    }
  }

  async function deleteEventModal(){
    if(!currentEventModalContext) return;
    try{
      if(currentEventModalContext.source === "google"){
        const googleId = currentEventModalContext.googleId || "";
        if(!googleId){
          showWarning("삭제할 일정이 없습니다.");
          return;
        }
        await deleteGoogleEventById(googleId);
      }else{
        const localId = currentEventModalContext.localId;
        if(!localId){
          showWarning("삭제할 일정이 없습니다.");
          return;
        }
        await fetch(`/api/events/${localId}`, { method:"DELETE" });
        markLocalCacheDirty();
      }
      closeEventModal();
      await refreshAll();
    }catch(err){
      console.error(err);
      showWarning("일정 삭제에 실패했습니다.");
    }
  }

  async function deleteGoogleEventById(eventId){
    if(!eventId) return;
    const res = await fetch(apiBase + "/google/events/" + encodeURIComponent(eventId), {
      method:"DELETE"
    });
    if(res.ok){
      markGoogleCacheDirty();
    }
  }

  function updateUndoButton(){
    const has = undoStack.length > 0;
    const count = undoStack.length;
    const label = has ? `되돌리기 (${count})` : "되돌리기";

    const mainBtn = document.getElementById("undo-last-btn");
    if(mainBtn){
      mainBtn.disabled = !has;
      mainBtn.setAttribute("aria-label", label);
      mainBtn.setAttribute("title", label);
      const badge = document.getElementById("undo-count-badge");
      if(badge){
        badge.textContent = has ? String(count) : "";
        badge.classList.toggle("is-hidden", !has);
      }
    }

    const drawerBtn = document.getElementById("drawer-undo-btn");
    if(drawerBtn){
      drawerBtn.disabled = !has;
      drawerBtn.textContent = label;
    }
  }

  function recordUndoBatch(events){
    if(!Array.isArray(events) || events.length === 0) return;
    const batch = events
      .map(ev => ({
        localId: (typeof ev.id === "number" || /^\d+$/.test(String(ev.id || ""))) ? parseInt(ev.id, 10) : null,
        googleId: ev.google_event_id || null
      }))
      .filter(item => item.localId || item.googleId);
    if(!batch.length) return;
    undoStack.push(batch);
    updateUndoButton();
  }

  async function undoLastBatch(){
    if(undoStack.length === 0) return;
    const batch = undoStack.pop();
    updateUndoButton();
    const localIds = batch.map(item => item.localId).filter(id => Number.isFinite(id));
    const googleIds = batch.map(item => item.googleId).filter(id => !!id);
    try{
      if(localIds.length){
        await fetch(apiBase + "/delete-by-ids", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ ids: localIds })
        });
        markLocalCacheDirty();
      }
      for(const gid of googleIds){
        await deleteGoogleEventById(gid);
      }
      await refreshAll();
    }catch(err){
      console.error(err);
      showWarning("되돌리기에 실패했습니다.");
    }
  }

  async function loadEventListForDate(dateStr){
    const targetDate = dateStr || "";
    const ul = document.getElementById("events-ul");
    ul.innerHTML = "";

    if(!targetDate){
      return;
    }

    let dayEvents = [];
    if(!IS_GOOGLE_MODE){
      let events = [];
      try{
        events = await getLocalEventsForRange(targetDate, targetDate);
      }catch(err){
        console.error(err);
        events = [];
      }
      dayEvents = events
        .filter(ev => eventCoversDate(ev, targetDate))
        .map(ev => ({ ...ev, _source: "local" }));
    }

    let googleDayEvents = [];
    if(IS_GOOGLE_MODE){
      try{
        googleDayEvents = collectGoogleEventsForDate(targetDate)
          .map(ev => ({ ...ev, _source: "google" }));
      }catch(err){
        console.error(err);
      }
    }

    const combined = [...dayEvents, ...googleDayEvents];

    combined.sort((a, b) => {
      const aStart = a.start || "";
      const bStart = b.start || "";
      if(aStart === bStart){
        return (a.title || "").localeCompare(b.title || "");
      }
      return aStart.localeCompare(bStart);
    });
    if(combined.length === 0){
      ul.innerHTML = "<li class='events-empty'>일정 없음</li>";
      return;
    }

    for(const ev of combined){
      const li = document.createElement("li");
      li.addEventListener("click", () => {
        openEventModal({
          id: ev.id,
          title: ev.title,
          start: ev.start,
          end: ev.end,
          location: ev.location,
          notes: "",
          source: ev._source || "local",
          googleId: ev.google_event_id || ev.id,
          allDay: ev.all_day
        });
      });

      const dot = document.createElement("div");
      dot.className = "event-dot";

      const info = document.createElement("div");
      info.className = "event-info";

      const title = document.createElement("div");
      title.className = "event-title";
      title.textContent = ev.title || "";

      const meta = document.createElement("div");
      meta.className = "event-meta";
      const locationIcon = document.createElement("span");
      locationIcon.className = "location-icon";
      locationIcon.setAttribute("aria-hidden", "true");
      locationIcon.innerHTML = "<svg viewBox='0 0 24 24' role='img' focusable='false' aria-hidden='true'><path d='M12 2c3.9 0 7 3.1 7 7 0 5.2-6 12.3-6.3 12.6-.4.4-1 .4-1.4 0C11 21.3 5 14.2 5 9c0-3.9 3.1-7 7-7zm0 4.2a2.8 2.8 0 1 0 0 5.6 2.8 2.8 0 0 0 0-5.6z'/></svg>";

      if(ev.location){
        const locationText = document.createElement("span");
        locationText.textContent = ev.location;
        meta.appendChild(locationIcon);
        meta.appendChild(locationText);
      }

      info.appendChild(title);
      if(meta.childNodes.length){
        info.appendChild(meta);
      }

      const timeBox = document.createElement("div");
      timeBox.className = "event-time";
      const startStr = ev.start || "";
      const endStr = ev.end || "";
      const isAllDay = (ev.all_day === true) || isAllDayRange(startStr, endStr);

      if(isAllDay){
        const line = document.createElement("div");
        line.className = "time-line";
        line.textContent = "하루종일";
        timeBox.appendChild(line);
      }else{
        const startLine = document.createElement("div");
        startLine.className = "time-line";
        startLine.textContent = startStr.length >= 16 ? startStr.slice(11,16) : "시작 없음";

        const endLine = document.createElement("div");
        endLine.className = "time-line";
        endLine.textContent = endStr.length >= 16 ? endStr.slice(11,16) : "종료 없음";

        timeBox.appendChild(startLine);
        timeBox.appendChild(endLine);
      }

      li.appendChild(dot);
      li.appendChild(info);
      li.appendChild(timeBox);
      ul.appendChild(li);
    }
  }

  // Recent added modal
  function closeRecentModal(){
    document.getElementById("recent-overlay").style.display = "none";
    const list = document.getElementById("recent-list");
    if(list) list.innerHTML = "";
  }

  async function loadRecentList(){
    const list = document.getElementById("recent-list");
    if(!list) return;
    list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>불러오는 중...</div>";
    try{
      const res = await fetch(apiBase + "/recent-events");
      if(!res.ok){
        list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>불러오기 실패</div>";
        return;
      }
      const data = await res.json();
      renderRecentList(Array.isArray(data) ? data : []);
    }catch(err){
      console.error(err);
      list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>불러오기 실패</div>";
    }
  }

  async function openRecentModal(){
    const overlay = document.getElementById("recent-overlay");
    if(!overlay) return;
    overlay.style.display = "flex";
    await loadRecentList();
  }

  function refreshRecentIfOpen(){
    const overlay = document.getElementById("recent-overlay");
    if(overlay && overlay.style.display === "flex"){
      loadRecentList();
    }
  }

  function renderRecentList(items){
    const list = document.getElementById("recent-list");
    if(!list) return;
    if(!items.length){
      list.innerHTML = "<div style='padding:10px; color:var(--muted); font-weight:800;'>최근 14일 내 추가된 일정이 없습니다.</div>";
      return;
    }
    list.innerHTML = "";
    items.forEach((ev) => {
      const source = ev.source || "local";
      const row = document.createElement("div");
      row.className = "recent-item";

      const badge = document.createElement("span");
      badge.className = "badge";
      badge.textContent = (source === "google") ? "Google" : (ev.all_day ? "하루종일" : "일정");

      const main = document.createElement("div");
      main.className = "recent-main";

      const l1 = document.createElement("div");
      l1.className = "recent-line1";
      l1.textContent = ev.title || "(제목 없음)";

      const l2 = document.createElement("div");
      l2.className = "recent-line2";
      l2.textContent = fmtRange(ev.start, ev.end, ev.all_day) + (ev.location ? ` · ${ev.location}` : "");

      const meta = document.createElement("div");
      meta.className = "recent-meta";
      meta.textContent = `추가: ${formatCreatedAt(ev.created_at || ev.created || "")}`;

      main.appendChild(l1);
      main.appendChild(l2);
      main.appendChild(meta);

      const del = document.createElement("button");
      del.className = "recent-delete";
      del.type = "button";
      del.textContent = "삭제";
      del.addEventListener("click", async () => {
        if(!confirm("이 일정을 삭제할까요?")) return;
        try{
          if(source === "google"){
            await deleteGoogleEventById(ev.google_event_id || ev.id);
          }else{
            await fetch(apiBase + "/events/" + ev.id, { method:"DELETE" });
            markLocalCacheDirty();
          }
          await refreshAll();
          await loadRecentList();
        }catch(err){
          console.error(err);
          showWarning("삭제에 실패했습니다.");
        }
      });

      row.appendChild(badge);
      row.appendChild(main);
      row.appendChild(del);
      list.appendChild(row);
    });
  }

  async function refreshAll(){
    if(IS_GOOGLE_MODE && googleCacheDirty){
      clearGoogleEventCache();
      googleCacheDirty = false;
    }
    if(calendar) calendar.refetchEvents();
    if(selectedDateStr) await loadEventListForDate(selectedDateStr);
    refreshRecentIfOpen();
  }

  async function createEvent(e){
    e.preventDefault();

    const title = document.getElementById("title").value.trim();
    const start = document.getElementById("start").value;
    const end = document.getElementById("end").value;
    const location = document.getElementById("location").value.trim();

    if(!title || !start){
      showWarning("제목과 시작 시각은 필수입니다.");
      return;
    }

    const payload = { title, start, end: end || null, location: location || null };

    const res = await fetch(apiBase + "/events", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });

    if(res.ok){
      const created = await res.json();
      recordUndoBatch([created]);
      markLocalCacheDirty();
    }else{
      showWarning("일정 추가에 실패했습니다.");
      return;
    }

    document.getElementById("event-form").reset();
    await refreshAll();
  }

  function setUnifiedMode(isDelete){
    const btn = document.getElementById("nlp-action-btn");
    const loaderEl = document.querySelector("#nlp-unified-loader .loader");
    const scopeControls = document.getElementById("delete-scope-controls");
    if(!btn) return;

    btn.classList.toggle("mode-delete", isDelete);
    btn.classList.toggle("mode-add", !isDelete);
    if(isDelete){
      resetNlpConversation();
    }

    if(loaderEl){
      loaderEl.classList.toggle("is-delete", isDelete);
    }
    if(scopeControls){
      scopeControls.style.display = isDelete ? "block" : "none";
    }
  }

  function setUnifiedBusy(isBusy){
    const btn = document.getElementById("nlp-action-btn");
    const loaderWrap = document.getElementById("nlp-unified-loader");
    if(!btn || !loaderWrap) return;

    btn.disabled = !!isBusy;
    btn.classList.toggle("scale-0", !!isBusy);
    btn.classList.toggle("scale-1", !isBusy);
    loaderWrap.classList.toggle("scale-1", !!isBusy);
    loaderWrap.classList.toggle("scale-0", !isBusy);
  }

  function setGlobalLoadingOverlayVisible(visible, message){
    const overlay = document.getElementById("global-loading-overlay");
    if(!overlay) return;
    if(message){
      const textEl = overlay.querySelector(".global-loading-text");
      if(textEl) textEl.textContent = message;
    }
    overlay.classList.toggle("active", !!visible);
    if(document && document.body){
      document.body.classList.toggle("global-loading-active", !!visible);
    }
  }

  function pushGlobalLoading(message){
    googleGlobalLoaderDepth += 1;
    setGlobalLoadingOverlayVisible(true, message || "불러오는 중..");
  }

  function popGlobalLoading(){
    googleGlobalLoaderDepth = Math.max(googleGlobalLoaderDepth - 1, 0);
    if(googleGlobalLoaderDepth === 0){
      setGlobalLoadingOverlayVisible(false);
    }
  }

  function markGoogleCacheDirty(){
    if(!IS_GOOGLE_MODE) return;
    googleCacheDirty = true;
  }

  function clearGoogleEventCache(){
    googleCacheGeneration += 1;
    Object.keys(googleEventCache).forEach((key) => delete googleEventCache[key]);
    Object.keys(googleEventFetches).forEach((key) => delete googleEventFetches[key]);
  }

  function normalizeGoogleEvent(ev){
    if(!ev) return null;
    let start = ev.start || "";
    const end = ev.end || null;
    if(!start && end){
      start = end;
    }
    if(!start) return null;
    const unique = ev.id || start || end || ev.html_link || `${Date.now()}-${Math.random()}`;
    return {
      id:`google:${unique}`,
      google_event_id: ev.id || "",
      title: ev.title || "(제목 없음)",
      start,
      end,
      location: ev.location || "",
      all_day: !!ev.all_day,
      source:"google"
    };
  }

  function getYearFromDateStr(value){
    if(!value || value.length < 4) return null;
    const num = parseInt(value.slice(0,4), 10);
    return Number.isFinite(num) ? num : null;
  }


  async function ensureGoogleEventsForYear(year){
    if(!IS_GOOGLE_MODE || !Number.isFinite(year)) return [];
    if(Array.isArray(googleEventCache[year])) return googleEventCache[year];
    if(googleEventFetches[year]) return googleEventFetches[year];

    const generationAtStart = googleCacheGeneration;
    const message = "불러오는 중..";
    const promise = (async () => {
      pushGlobalLoading(message);
      try{
        const params = new URLSearchParams({
          start_date: `${year}-01-01`,
          end_date: `${year}-12-31`
        });
        const res = await fetch(apiBase + "/google/events?" + params.toString());
        if(!res.ok){
          throw new Error("Google 일정 불러오기 실패");
        }
        const raw = await res.json();
        const normalized = (Array.isArray(raw) ? raw : []).map(normalizeGoogleEvent).filter(Boolean);
        if(generationAtStart === googleCacheGeneration){
          googleEventCache[year] = normalized;
        }
        return normalized;
      }finally{
        popGlobalLoading();
        delete googleEventFetches[year];
      }
    })().catch((err) => {
      console.error(err);
      throw err;
    });

    googleEventFetches[year] = promise;
    return promise;
  }

  async function ensureGoogleEventsForYears(years){
    if(!IS_GOOGLE_MODE) return;
    const uniqueYears = Array.from(new Set((years || []).filter((y) => Number.isFinite(y))));
    if(!uniqueYears.length) return;
    await Promise.all(uniqueYears.map((year) => ensureGoogleEventsForYear(year)));
  }

  async function ensureGoogleEventsForDate(dateStr){
    if(!IS_GOOGLE_MODE || !dateStr) return;
    const year = getYearFromDateStr(dateStr);
    if(Number.isFinite(year)){
      await ensureGoogleEventsForYear(year);
    }
  }

  function collectGoogleEventsForDate(dateStr){
    if(!IS_GOOGLE_MODE || !dateStr) return [];
    const results = [];
    Object.values(googleEventCache).forEach((bucket) => {
      if(!Array.isArray(bucket)) return;
      bucket.forEach((ev) => {
        if(eventCoversDate(ev, dateStr)){
          results.push(ev);
        }
      });
    });
    return results;
  }

  function collectGoogleEventsBetween(startDateStr, endDateStr){
    if(!IS_GOOGLE_MODE || !startDateStr || !endDateStr) return [];
    const results = [];
    Object.values(googleEventCache).forEach((bucket) => {
      if(!Array.isArray(bucket)) return;
      bucket.forEach((ev) => {
        if(eventIntersectsRange(ev, startDateStr, endDateStr)){
          results.push(ev);
        }
      });
    });
    return results;
  }

  // -------- Image attachment helpers --------
  function estimateDataUrlBytes(dataUrl){
    if(typeof dataUrl !== "string") return 0;
    const commaIdx = dataUrl.indexOf(",");
    const b64 = commaIdx >= 0 ? dataUrl.slice(commaIdx + 1) : dataUrl;
    return Math.ceil((b64.length * 3) / 4);
  }

  function clampDimensions(width, height, maxDim){
    if(width <= maxDim && height <= maxDim){
      return { width, height };
    }
    const scale = Math.min(maxDim / width, maxDim / height);
    return {
      width: Math.max(1, Math.round(width * scale)),
      height: Math.max(1, Math.round(height * scale))
    };
  }

  function readFileAsDataURL(file){
    return new Promise((resolve, reject) => {
      const reader = new FileReader();
      reader.onload = () => resolve(reader.result);
      reader.onerror = reject;
      reader.readAsDataURL(file);
    });
  }

  function loadImageElement(src){
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => resolve(img);
      img.onerror = reject;
      img.src = src;
    });
  }

  async function compressImageFile(file){
    const base64 = await readFileAsDataURL(file);
    const img = await loadImageElement(base64);
    const { width, height } = clampDimensions(img.width, img.height, MAX_IMAGE_DIMENSION);
    const canvas = document.createElement("canvas");
    canvas.width = width;
    canvas.height = height;
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0, 0, width, height);
    ctx.drawImage(img, 0, 0, width, height);

    let quality = 0.92;
    let dataUrl = canvas.toDataURL("image/jpeg", quality);
    let attempts = 0;
    while(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES && attempts < 5){
      quality = Math.max(0.5, quality - 0.1);
      dataUrl = canvas.toDataURL("image/jpeg", quality);
      attempts += 1;
    }
    if(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES){
      throw new Error("이미지 용량 초과");
    }
    return dataUrl;
  }

  async function handleImageFiles(fileList){
    if(!fileList) return;
    const files = Array.from(fileList);
    if(nlpImageAttachments.length >= MAX_IMAGE_ATTACHMENTS){
      showWarning(`이미지는 최대 ${MAX_IMAGE_ATTACHMENTS}장까지만 첨부할 수 있습니다.`);
      return;
    }
    for(const file of files){
      if(nlpImageAttachments.length >= MAX_IMAGE_ATTACHMENTS){
        showWarning(`이미지는 최대 ${MAX_IMAGE_ATTACHMENTS}장까지만 첨부할 수 있습니다.`);
        break;
      }
      if(!file.type.startsWith("image/")) continue;
      try{
        const dataUrl = await compressImageFile(file);
        nlpImageAttachments.push({
          id: imageAttachmentSeq++,
          name: file.name || `image-${imageAttachmentSeq}`,
          dataUrl
        });
      }catch(err){
        console.error(err);
        showWarning("이미지를 처리하지 못했습니다. 해상도를 줄이거나 다른 이미지를 사용해주세요.");
      }
    }
    renderNlpImageAttachments();
  }

  function renderNlpImageAttachments(){
    const host = document.getElementById("nlp-image-attachments");
    if(!host) return;
    host.innerHTML = "";
    nlpImageAttachments.forEach((att) => {
      const chip = document.createElement("div");
      chip.className = "image-chip";

      const img = document.createElement("img");
      img.src = att.dataUrl;
      img.alt = att.name || "attachment";
      chip.appendChild(img);

      const actions = document.createElement("div");
      actions.className = "image-chip-actions";

      const maskBtn = document.createElement("button");
      maskBtn.type = "button";
      maskBtn.textContent = "가리기";
      maskBtn.addEventListener("click", () => openImageEditor(att.id));
      actions.appendChild(maskBtn);

      const removeBtn = document.createElement("button");
      removeBtn.type = "button";
      removeBtn.textContent = "삭제";
      removeBtn.addEventListener("click", () => removeImageAttachment(att.id));
      actions.appendChild(removeBtn);

      chip.appendChild(actions);
      host.appendChild(chip);
    });
  }

  function escapeNlpHtml(value){
    return (value || "")
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/\"/g, "&quot;");
  }

  function formatNlpInline(text){
    const safe = escapeNlpHtml(text);
    const withBold = safe.replace(/\*\*(.+?)\*\*/g, "<strong>$1</strong>");
    return withBold.replace(/\*(.+?)\*/g, "<em>$1</em>");
  }

  function renderNlpBubbleText(host, rawText){
    if(!host) return;
    host.innerHTML = "";
    const normalized = (rawText || "").toString().replace(/\\n/g, "\n");
    const lines = normalized.split(/\r?\n/);
    let listEl = null;

    const flushList = () => {
      if(listEl){
        host.appendChild(listEl);
        listEl = null;
      }
    };

    lines.forEach((line, idx) => {
      if(line.startsWith("- ")){
        if(!listEl){
          listEl = document.createElement("ul");
        }
        const li = document.createElement("li");
        li.innerHTML = formatNlpInline(line.slice(2));
        listEl.appendChild(li);
        return;
      }

      flushList();
      if(line === ""){
        host.appendChild(document.createElement("br"));
        return;
      }
      const span = document.createElement("span");
      span.innerHTML = formatNlpInline(line);
      host.appendChild(span);
      if(idx < lines.length - 1){
        host.appendChild(document.createElement("br"));
      }
    });

    flushList();
  }

  function renderNlpConversation(){
    const host = document.getElementById("nlp-chat");
    if(!host) return;
    host.innerHTML = "";
    nlpConversation.forEach((msg) => {
      const bubble = document.createElement("div");
      bubble.className = `nlp-msg ${msg.role}`;
      renderNlpBubbleText(bubble, msg.text);
      host.appendChild(bubble);
    });
  }

  function appendNlpMessage(role, text, options = {}){
    const value = (text || "").toString().trim();
    if(!value) return;
    const safeRole = role === "assistant" ? "assistant" : "user";
    const includeInPrompt = options.includeInPrompt !== false;
    nlpConversation.push({ role: safeRole, text: value, includeInPrompt });
    renderNlpConversation();
  }

  function buildNlpConversationText(){
    if(nlpConversation.length === 0){
      return "";
    }
    return nlpConversation
      .filter((msg) => msg.includeInPrompt !== false)
      .map((msg) => `${msg.role === "assistant" ? "assistant" : "사용자"}: ${msg.text}`)
      .join("\n");
  }

  function resetNlpConversation(){
    nlpConversation.length = 0;
    renderNlpConversation();
  }

  function removeImageAttachment(id){
    const idx = nlpImageAttachments.findIndex(att => att.id === id);
    if(idx >= 0){
      nlpImageAttachments.splice(idx, 1);
      renderNlpImageAttachments();
    }
  }

  function getNlpImagePayload(){
    return nlpImageAttachments.map(att => att.dataUrl);
  }

  function resetNlpComposerInputs(){
    const input = document.getElementById("nlp-unified-text");
    if(input){
      input.value = "";
      input.dispatchEvent(new Event("input"));
    }
    nlpImageAttachments.length = 0;
    renderNlpImageAttachments();
  }

  function resetRecurrenceEndSelections(){
    recurrenceEndSelections.clear();
  }

  function getRecurrenceEndSelection(idx){
    return recurrenceEndSelections.get(idx);
  }

  function setRecurrenceEndSelection(idx, payload){
    recurrenceEndSelections.set(idx, payload);
  }

  function buildRecurrenceEndControls(item, idx){
    const box = document.createElement("div");
    box.className = "rec-end-box";

    const title = document.createElement("h3");
    title.textContent = "반복 종료를 선택해주세요";
    box.appendChild(title);

    const options = document.createElement("div");
    options.className = "rec-end-options";
    const optionDefs = [
      { value:"none", label:"무기한" },
      { value:"until", label:"종료 날짜" },
      { value:"count", label:"횟수" }
    ];
    const name = `rec-end-${idx}`;

    const extra = document.createElement("div");
    extra.className = "rec-end-extra";

    const dateInput = document.createElement("input");
    dateInput.type = "date";
    dateInput.value = item.end_date || item.start_date || "";
    extra.appendChild(dateInput);

    const countInput = document.createElement("input");
    countInput.type = "number";
    countInput.min = "1";
    countInput.placeholder = "횟수";
    extra.appendChild(countInput);

    let currentMode = "none";

    const updateSelection = () => {
      if(currentMode === "until"){
        extra.style.display = "flex";
        dateInput.style.display = "";
        countInput.style.display = "none";
      }else if(currentMode === "count"){
        extra.style.display = "flex";
        dateInput.style.display = "none";
        countInput.style.display = "";
      }else{
        extra.style.display = "none";
        dateInput.style.display = "none";
        countInput.style.display = "none";
      }

      if(currentMode === "until"){
        setRecurrenceEndSelection(idx, {
          mode:"until",
          value: dateInput.value || null
        });
      }else if(currentMode === "count"){
        const numeric = countInput.value ? parseInt(countInput.value, 10) : null;
        setRecurrenceEndSelection(idx, {
          mode:"count",
          value: Number.isFinite(numeric) && numeric > 0 ? numeric : null
        });
      }else{
        setRecurrenceEndSelection(idx, { mode:"none", value:null });
      }
    };

    optionDefs.forEach(def => {
      const label = document.createElement("label");
      label.className = "rec-end-option";

      const radio = document.createElement("input");
      radio.type = "radio";
      radio.name = name;
      radio.value = def.value;
      if(def.value === "none"){
        radio.checked = true;
      }
      radio.addEventListener("change", () => {
        currentMode = def.value;
        updateSelection();
      });

      label.appendChild(radio);
      label.appendChild(document.createTextNode(def.label));
      options.appendChild(label);
    });

    dateInput.addEventListener("change", updateSelection);
    countInput.addEventListener("change", updateSelection);

    box.appendChild(options);
    box.appendChild(extra);
    currentMode = "none";
    updateSelection();
    return box;
  }

  function loadReasoningEffortFromStorage(){
    if(!IS_ADMIN) return;
    try{
      const stored = localStorage.getItem(REASONING_EFFORT_KEY);
      if(stored && ALLOWED_REASONING_EFFORTS.includes(stored)){
        reasoningEffortValue = stored;
      }
    }catch(_err){
      reasoningEffortValue = DEFAULT_REASONING_EFFORT;
    }
  }

  function saveReasoningEffortToStorage(value){
    if(!IS_ADMIN) return;
    try{
      localStorage.setItem(REASONING_EFFORT_KEY, value);
    }catch(_err){
      /* ignore */
    }
  }

  function initReasoningEffortControl(){
    const wrap = document.getElementById("reasoning-effort-control");
    const select = document.getElementById("reasoning-effort-select");
    if(!wrap || !select) return;
    if(!IS_ADMIN){
      wrap.style.display = "none";
      return;
    }
    loadReasoningEffortFromStorage();
    wrap.style.display = "flex";
    select.value = reasoningEffortValue;
    select.addEventListener("change", () => {
      const val = select.value;
      if(ALLOWED_REASONING_EFFORTS.includes(val)){
        reasoningEffortValue = val;
        saveReasoningEffortToStorage(val);
      }else{
        select.value = reasoningEffortValue;
      }
    });
  }

  function getReasoningEffortSetting(){
    if(!IS_ADMIN) return null;
    const select = document.getElementById("reasoning-effort-select");
    const candidate = select ? select.value : reasoningEffortValue;
    return ALLOWED_REASONING_EFFORTS.includes(candidate) ? candidate : null;
  }

  function openImageEditor(attachmentId){
    const target = nlpImageAttachments.find(att => att.id === attachmentId);
    if(!target || !imageEditorOverlay || !imageEditorCanvas || !imageEditorCtx){
      return;
    }
    imageEditorState.attachmentId = attachmentId;
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    setEditorCanvasFromDataUrl(target.dataUrl, true).then(() => {
      imageEditorOverlay.classList.add("active");
    }).catch(() => {
      showWarning("이미지 편집 도중 오류가 발생했습니다.");
      imageEditorState.attachmentId = null;
    });
  }

  function closeImageEditor(){
    if(imageEditorOverlay){
      imageEditorOverlay.classList.remove("active");
    }
    imageEditorState.attachmentId = null;
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    if(imageEditorSelectionCtx && imageEditorSelection){
      imageEditorSelectionCtx.clearRect(0, 0, imageEditorSelection.width, imageEditorSelection.height);
    }
  }

  function setEditorCanvasFromDataUrl(dataUrl, resetUndo){
    if(!imageEditorCanvas || !imageEditorCtx) return Promise.reject(new Error("canvas missing"));
    return new Promise((resolve, reject) => {
      const img = new Image();
      img.onload = () => {
        const { width, height } = clampDimensions(img.width, img.height, MAX_IMAGE_DIMENSION);
        imageEditorCanvas.width = width;
        imageEditorCanvas.height = height;
        if(imageEditorSelection){
          imageEditorSelection.width = width;
          imageEditorSelection.height = height;
        }
        imageEditorCtx.clearRect(0, 0, width, height);
        imageEditorCtx.drawImage(img, 0, 0, width, height);
        if(imageEditorSelectionCtx){
          imageEditorSelectionCtx.clearRect(0, 0, width, height);
        }
        if(resetUndo){
          imageEditorUndoStack = [imageEditorCanvas.toDataURL("image/png")];
        }
        resolve();
      };
      img.onerror = reject;
      img.src = dataUrl;
    });
  }

  function pushEditorSnapshot(){
    if(!imageEditorCanvas) return;
    const snapshot = imageEditorCanvas.toDataURL("image/png");
    imageEditorUndoStack.push(snapshot);
    if(imageEditorUndoStack.length > 10){
      imageEditorUndoStack.shift();
    }
  }

  function undoImageEditor(){
    if(imageEditorUndoStack.length <= 1) return;
    imageEditorUndoStack.pop();
    const previous = imageEditorUndoStack[imageEditorUndoStack.length - 1];
    setEditorCanvasFromDataUrl(previous, false);
  }

  function getEditorPointerPosition(evt){
    if(!imageEditorSelection) return { x: 0, y: 0 };
    const rect = imageEditorSelection.getBoundingClientRect();
    const scaleX = imageEditorSelection.width / rect.width;
    const scaleY = imageEditorSelection.height / rect.height;
    return {
      x: (evt.clientX - rect.left) * scaleX,
      y: (evt.clientY - rect.top) * scaleY
    };
  }

  function clearSelectionOverlay(){
    if(imageEditorSelectionCtx && imageEditorSelection){
      imageEditorSelectionCtx.clearRect(0, 0, imageEditorSelection.width, imageEditorSelection.height);
    }
  }

  function drawSelectionPreview(x1, y1, x2, y2){
    if(!imageEditorSelectionCtx) return;
    clearSelectionOverlay();
    const x = Math.min(x1, x2);
    const y = Math.min(y1, y2);
    const w = Math.abs(x2 - x1);
    const h = Math.abs(y2 - y1);
    if(w < 4 || h < 4) return;
    imageEditorSelectionCtx.fillStyle = "rgba(0,0,0,0.35)";
    imageEditorSelectionCtx.fillRect(x, y, w, h);
    imageEditorSelectionCtx.strokeStyle = "rgba(0,0,0,0.8)";
    imageEditorSelectionCtx.lineWidth = 2;
    imageEditorSelectionCtx.strokeRect(x + 1, y + 1, Math.max(0, w - 2), Math.max(0, h - 2));
  }

  function commitBlackout(x1, y1, x2, y2){
    if(!imageEditorCanvas || !imageEditorCtx) return;
    const w = Math.abs(x2 - x1);
    const h = Math.abs(y2 - y1);
    if(w < 4 || h < 4) return;
    const x = Math.max(0, Math.min(x1, x2));
    const y = Math.max(0, Math.min(y1, y2));
    imageEditorCtx.fillStyle = "#000000";
    imageEditorCtx.globalAlpha = 1;
    imageEditorCtx.fillRect(x, y, w, h);
    pushEditorSnapshot();
  }

  function imageEditorPointerDown(evt){
    if(!imageEditorSelection) return;
    evt.preventDefault();
    const { x, y } = getEditorPointerPosition(evt);
    imageEditorState.drawing = true;
    imageEditorState.pointerId = evt.pointerId;
    imageEditorState.startX = x;
    imageEditorState.startY = y;
    imageEditorSelection.setPointerCapture?.(evt.pointerId);
  }

  function imageEditorPointerMove(evt){
    if(!imageEditorState.drawing || imageEditorState.pointerId !== evt.pointerId) return;
    evt.preventDefault();
    const { x, y } = getEditorPointerPosition(evt);
    drawSelectionPreview(imageEditorState.startX, imageEditorState.startY, x, y);
  }

  function imageEditorPointerUp(evt){
    if(!imageEditorState.drawing || imageEditorState.pointerId !== evt.pointerId) return;
    evt.preventDefault();
    const { x, y } = getEditorPointerPosition(evt);
    commitBlackout(imageEditorState.startX, imageEditorState.startY, x, y);
    clearSelectionOverlay();
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    imageEditorSelection?.releasePointerCapture?.(evt.pointerId);
  }

  function imageEditorPointerCancel(evt){
    if(imageEditorState.pointerId !== evt.pointerId) return;
    clearSelectionOverlay();
    imageEditorState.drawing = false;
    imageEditorState.pointerId = null;
    imageEditorSelection?.releasePointerCapture?.(evt.pointerId);
  }

  function applyImageEditorEdits(){
    if(imageEditorState.attachmentId == null || !imageEditorCanvas){
      closeImageEditor();
      return;
    }
    let quality = 0.9;
    let dataUrl = imageEditorCanvas.toDataURL("image/jpeg", quality);
    let attempts = 0;
    while(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES && attempts < 4){
      quality = Math.max(0.5, quality - 0.1);
      dataUrl = imageEditorCanvas.toDataURL("image/jpeg", quality);
      attempts += 1;
    }
    if(estimateDataUrlBytes(dataUrl) > MAX_IMAGE_BYTES){
      showWarning("편집 결과 이미지가 너무 큽니다. 가린 영역을 줄이거나 이미지를 축소해주세요.");
      return;
    }
    const target = nlpImageAttachments.find(att => att.id === imageEditorState.attachmentId);
    if(target){
      target.dataUrl = dataUrl;
      renderNlpImageAttachments();
    }
    closeImageEditor();
  }

  function setupImageComposer(){
    const attachBtn = document.getElementById("nlp-attach-btn");
    const fileInput = document.getElementById("nlp-image-input");
    imageEditorOverlay = document.getElementById("image-editor-overlay");
    imageEditorCanvas = document.getElementById("image-editor-canvas");
    imageEditorCtx = imageEditorCanvas?.getContext("2d") || null;
    imageEditorSelection = document.getElementById("image-editor-selection");
    imageEditorSelectionCtx = imageEditorSelection?.getContext("2d") || null;

    attachBtn?.addEventListener("click", () => fileInput?.click());
    fileInput?.addEventListener("change", async (event) => {
      await handleImageFiles(event.target.files);
      event.target.value = "";
    });

    document.getElementById("image-editor-cancel")?.addEventListener("click", closeImageEditor);
    document.getElementById("image-editor-apply")?.addEventListener("click", applyImageEditorEdits);
    document.getElementById("image-editor-undo")?.addEventListener("click", undoImageEditor);
    imageEditorOverlay?.addEventListener("click", (event) => {
      if(event.target === imageEditorOverlay){
        closeImageEditor();
      }
    });

    imageEditorSelection?.addEventListener("pointerdown", imageEditorPointerDown, { passive: false });
    imageEditorSelection?.addEventListener("pointermove", imageEditorPointerMove, { passive: false });
    imageEditorSelection?.addEventListener("pointerup", imageEditorPointerUp, { passive: false });
    imageEditorSelection?.addEventListener("pointercancel", imageEditorPointerCancel, { passive: false });
    imageEditorSelection?.addEventListener("pointerleave", imageEditorPointerCancel, { passive: false });

    renderNlpImageAttachments();
  }

  function setupEventModalControls(){
    const overlay = document.getElementById("event-modal-overlay");
    if(!overlay) return;
    document.getElementById("event-modal-close")?.addEventListener("click", closeEventModal);
    document.getElementById("event-modal-cancel")?.addEventListener("click", closeEventModal);
    document.getElementById("event-modal-save")?.addEventListener("click", saveEventModal);
    document.getElementById("event-modal-delete")?.addEventListener("click", deleteEventModal);
    overlay.addEventListener("click", (event) => {
      if(event.target === overlay){
        closeEventModal();
      }
    });
  }

  // -------- Confirm Modal helpers --------
  function openConfirm(){ document.getElementById("confirm-overlay").style.display = "flex"; }
  function closeConfirm(){
    document.getElementById("confirm-overlay").style.display = "none";
    document.getElementById("confirm-list").innerHTML = "";
    confirmState = { mode: null, addItems: [], deleteGroups: [] };
    resetRecurrenceEndSelections();
  }

  async function openAddConfirm(text, imagePayload = []){
    appendNlpMessage("user", text);
    const payloadText = buildNlpConversationText() || text;
    const payload = { text: payloadText };
    if(Array.isArray(imagePayload) && imagePayload.length){
      payload.images = imagePayload;
    }
    const effort = getReasoningEffortSetting();
    if(effort){
      payload.reasoning_effort = effort;
    }
    const res = await fetch(apiBase + "/nlp-preview", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      showWarning("추가할 일정을 해석하지 못했습니다.");
      return;
    }
    const data = await res.json();
    if(data && data.context_used){
      appendNlpMessage("assistant", "기존 일정 분석 중", { includeInPrompt: false });
      appendNlpMessage("assistant", "기존 일정 분석 완료", { includeInPrompt: false });
    }
    if(data && data.need_more_information){
      const question = (data.content || "").trim();
      if(question){
        appendNlpMessage("assistant", question);
      }else{
        showWarning("추가로 확인할 정보가 필요합니다.");
      }
      const input = document.getElementById("nlp-unified-text");
      if(input){
        input.value = "";
        input.dispatchEvent(new Event("input"));
      }
      return;
    }
    const items = Array.isArray(data?.items) ? data.items : [];
    if(items.length === 0){
      showWarning("추가할 일정을 찾지 못했습니다.");
      return;
    }

    confirmState.mode = "add";
    confirmState.addItems = items;
    resetRecurrenceEndSelections();

    document.getElementById("confirm-title").textContent = "이 일정을 추가할까요?";
    document.getElementById("confirm-desc").textContent = "체크한 항목만 추가됩니다. 반복 일정은 묶어서 선택하거나 상세에서 일부만 고를 수 있습니다.";

    const host = document.getElementById("confirm-list");
    host.innerHTML = "";

    const createEditableLabel = (initial, placeholder, onCommit) => {
      let currentValue = initial || "";
      const wrapper = document.createElement("div");
      wrapper.className = "cm-editable";
      let label = document.createElement("span");
      label.textContent = currentValue || placeholder;
      const iconBtn = document.createElement("button");
      iconBtn.type = "button";
      iconBtn.className = "cm-edit-icon";
      iconBtn.innerHTML = `<svg viewBox="0 0 24 24" aria-hidden="true" focusable="false"><path d="M3 17.25V21h3.75L17.81 9.94l-3.75-3.75L3 17.25zm2.92.83h-.67v-.67l8.5-8.5.67.67-8.5 8.5zM20.71 7.04a1 1 0 0 0 0-1.41l-2.34-2.34a1 1 0 0 0-1.41 0l-1.83 1.83 3.75 3.75 1.83-1.83z"/></svg>`;

      const applyLabel = (value) => {
        currentValue = value || "";
        if(label) label.textContent = currentValue || placeholder;
      };

      const enterEdit = () => {
        if(wrapper.classList.contains("editing")) return;
        wrapper.classList.add("editing");
        const input = document.createElement("input");
        input.type = "text";
        input.value = currentValue || "";
        wrapper.insertBefore(input, iconBtn);
        if(label) label.remove();
        iconBtn.style.visibility = "hidden";
        input.focus();

        const finish = (apply) => {
          if(apply){
            const nextValue = input.value.trim();
            currentValue = nextValue;
            onCommit(nextValue);
          }
          input.remove();
          label = document.createElement("span");
          label.textContent = currentValue || placeholder;
          wrapper.insertBefore(label, iconBtn);
          iconBtn.style.visibility = "";
          wrapper.classList.remove("editing");
        };

        input.addEventListener("blur", () => finish(true));
        input.addEventListener("keydown", (e) => {
          if(e.key === "Enter"){
            e.preventDefault();
            finish(true);
          }else if(e.key === "Escape"){
            e.preventDefault();
            finish(false);
          }
        });
      };

      wrapper.appendChild(label);
      wrapper.appendChild(iconBtn);
      wrapper.addEventListener("click", enterEdit);
      iconBtn.addEventListener("click", (event) => {
        event.preventDefault();
        event.stopPropagation();
        enterEdit();
      });

      return {
        wrapper,
        updateLabel: applyLabel
      };
    };

    items.forEach((it, idx) => {
      const row = document.createElement("div");
      row.className = "cm-row";

      const top = document.createElement("div");
      top.className = "cm-row-top";

      const left = document.createElement("div");
      left.className = "cm-left";

      const cb = document.createElement("input");
      cb.type = "checkbox";
      cb.checked = true;
      cb.className = "cm-check";
      cb.dataset.addIndex = String(idx);
      cb.dataset.role = "add-top";

      const main = document.createElement("div");
      main.className = "cm-main";

      const line1 = document.createElement("div");
      line1.className = "cm-line1";

      const line2 = document.createElement("div");
      line2.className = "cm-line2";

      const locationLine = document.createElement("div");
      locationLine.className = "cm-line-location";

      if(it.type === "single"){
        const titleEditable = createEditableLabel(it.title || "", "(제목 없음)", (val) => {
          it.title = val || "";
          updateSingleMeta();
        });
        const locationEditable = createEditableLabel(it.location || "", "(장소 없음)", (val) => {
          it.location = (val && val.trim()) || null;
          updateSingleMeta();
        });

        const updateSingleMeta = () => {
          titleEditable.updateLabel(it.title || "");
          locationEditable.updateLabel(it.location || "");
          line2.textContent = fmtRange(it.start, it.end, it.all_day);
        };
        updateSingleMeta();

        line1.appendChild(titleEditable.wrapper);
        locationLine.appendChild(locationEditable.wrapper);
        main.appendChild(line1);
        main.appendChild(locationLine);
        main.appendChild(line2);
        left.appendChild(cb);
        left.appendChild(main);
        top.appendChild(left);
        row.appendChild(top);
        host.appendChild(row);
        return;
      }

      const sd = it.start_date || "?";
      const ed = it.end_date || "?";
      const cnt = (typeof it.count === "number") ? it.count : 0;
      const time = it.time ? it.time : "시간 없음";

      const recurTitleEditable = createEditableLabel(it.title || "", "(제목 없음)", (val) => {
        it.title = val || "";
        updateRecurringMeta();
      });
      const recurLocationEditable = createEditableLabel(it.location || "", "(장소 없음)", (val) => {
        it.location = (val && val.trim()) || null;
        updateRecurringMeta();
      });

      const updateRecurringMeta = () => {
        recurTitleEditable.updateLabel(it.title || "");
        recurLocationEditable.updateLabel(it.location || "");
        line2.textContent = `반복: ${sd}~${ed} · ${time} · ${cnt}회`;
      };
      updateRecurringMeta();

      line1.appendChild(recurTitleEditable.wrapper);
      locationLine.appendChild(recurLocationEditable.wrapper);

      main.appendChild(line1);
      main.appendChild(locationLine);
      main.appendChild(line2);

      if(Array.isArray(it.samples) && it.samples.length){
        const mini = document.createElement("div");
        mini.className = "cm-mini";
        const s = it.samples.slice(0,3).map(x => (x || "").replace("T"," ")).join(" / ");
        mini.textContent = `예: ${s}${(cnt > 3) ? " …" : ""}`;
        main.appendChild(mini);
      }

      left.appendChild(cb);
      left.appendChild(main);

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "cm-toggle";
      toggle.textContent = "상세";

      const sub = document.createElement("div");
      sub.className = "cm-sublist";

      const occ = Array.isArray(it.occurrences) ? it.occurrences : [];
      occ.forEach((occurrence, occIdx) => {
        const subItem = document.createElement("div");
        subItem.className = "cm-subitem";

        const occCb = document.createElement("input");
        occCb.type = "checkbox";
        occCb.checked = true;
        occCb.dataset.role = "add-occurrence";
        occCb.dataset.addIndex = String(idx);
        occCb.dataset.addOccurrenceIndex = String(occIdx);

        const info = document.createElement("div");
        info.style.minWidth = "0";

        const oLine1 = document.createElement("div");
        oLine1.className = "cm-line1";
        oLine1.textContent = occurrence.title || it.title || "";

        const oLine2 = document.createElement("div");
        oLine2.className = "cm-line2";
        oLine2.textContent = fmtRange(occurrence.start, occurrence.end, occurrence.all_day) + (occurrence.location ? ` · ${occurrence.location}` : "");

        info.appendChild(oLine1);
        info.appendChild(oLine2);

        subItem.appendChild(occCb);
        subItem.appendChild(info);
        sub.appendChild(subItem);
      });

      cb.addEventListener("change", () => {
        cb.indeterminate = false;
        sub.querySelectorAll("input[type=checkbox][data-role='add-occurrence']").forEach(x => {
          x.checked = cb.checked;
        });
      });

      sub.addEventListener("change", () => {
        const cbs = Array.from(sub.querySelectorAll("input[type=checkbox][data-role='add-occurrence']"));
        const all = cbs.every(x => x.checked);
        const any = cbs.some(x => x.checked);
        cb.checked = any;
        cb.indeterminate = any && !all;
      });

      toggle.addEventListener("click", () => {
        const open = sub.style.display === "block";
        sub.style.display = open ? "none" : "block";
        toggle.textContent = open ? "상세" : "접기";
      });

      top.appendChild(left);
      top.appendChild(toggle);
      row.appendChild(top);
      row.appendChild(sub);
      if(it.requires_end_confirmation){
        const endControls = buildRecurrenceEndControls(it, idx);
        row.appendChild(endControls);
      }
      host.appendChild(row);
    });

    openConfirm();
  }

  async function openDeleteConfirm(text, scope){
    if(!scope) return;
    const payload = { text, start_date: scope.start, end_date: scope.end };
    const effort = getReasoningEffortSetting();
    if(effort){
      payload.reasoning_effort = effort;
    }
    const res = await fetch(apiBase + "/nlp-delete-preview", {
      method:"POST",
      headers:{ "Content-Type":"application/json" },
      body: JSON.stringify(payload)
    });
    if(!res.ok){
      showWarning("삭제할 일정을 찾지 못했습니다.");
      return;
    }
    const data = await res.json();
    const groups = Array.isArray(data?.groups) ? data.groups : [];
    if(groups.length === 0){
      showWarning("삭제할 일정을 찾지 못했습니다.");
      return;
    }

    confirmState.mode = "delete";
    confirmState.deleteGroups = groups;

    document.getElementById("confirm-title").textContent = "이 일정을 삭제할까요?";
    document.getElementById("confirm-desc").textContent = "체크한 항목만 삭제됩니다. 반복 일정은 묶어서 선택할 수 있습니다.";

    const host = document.getElementById("confirm-list");
    host.innerHTML = "";

    groups.forEach((g, gi) => {
      const row = document.createElement("div");
      row.className = "cm-row";

      const top = document.createElement("div");
      top.className = "cm-row-top";

      const left = document.createElement("div");
      left.className = "cm-left";

      const gcb = document.createElement("input");
      gcb.type = "checkbox";
      gcb.checked = true;
      gcb.className = "cm-check";
      gcb.dataset.groupIndex = String(gi);

      const main = document.createElement("div");
      main.className = "cm-main";

      const line1 = document.createElement("div");
      line1.className = "cm-line1";
      const kindLabel = (g.kind === "recurring") ? "반복" : "단일";
      line1.textContent = `${kindLabel} · ${g.title || ""}`;

      const line2 = document.createElement("div");
      line2.className = "cm-line2";
      const time = g.time ? g.time : "";
      const loc = g.location ? g.location : "";
      const cnt = (typeof g.count === "number") ? g.count : (Array.isArray(g.ids) ? g.ids.length : 0);
      line2.textContent = `${time}${time && loc ? " · " : ""}${loc}${(time || loc) ? " · " : ""}${cnt}개`;

      main.appendChild(line1);
      main.appendChild(line2);

      left.appendChild(gcb);
      left.appendChild(main);

      const toggle = document.createElement("button");
      toggle.type = "button";
      toggle.className = "cm-toggle";
      toggle.textContent = "상세";

      const sub = document.createElement("div");
      sub.className = "cm-sublist";

      const items = Array.isArray(g.items) ? g.items : [];
      items.forEach((it) => {
        const si = document.createElement("div");
        si.className = "cm-subitem";

        const cb = document.createElement("input");
        cb.type = "checkbox";
        cb.checked = true;
        cb.dataset.deleteId = String(it.id);

        const meta = document.createElement("div");
        meta.style.minWidth = "0";

        const l1 = document.createElement("div");
        l1.className = "cm-line1";
        l1.textContent = it.title || "";

        const l2 = document.createElement("div");
        l2.className = "cm-line2";
        l2.textContent = fmtRange(it.start, it.end, it.all_day) + (it.location ? ` · ${it.location}` : "");

        meta.appendChild(l1);
        meta.appendChild(l2);

        si.appendChild(cb);
        si.appendChild(meta);
        sub.appendChild(si);
      });

      gcb.addEventListener("change", () => {
        sub.querySelectorAll("input[type=checkbox][data-delete-id]").forEach(x => {
          x.checked = gcb.checked;
          x.indeterminate = false;
        });
      });

      sub.addEventListener("change", () => {
        const cbs = Array.from(sub.querySelectorAll("input[type=checkbox][data-delete-id]"));
        const all = cbs.every(x => x.checked);
        const any = cbs.some(x => x.checked);
        gcb.checked = any;
        gcb.indeterminate = any && !all;
      });

      toggle.addEventListener("click", () => {
        const open = sub.style.display === "block";
        sub.style.display = open ? "none" : "block";
        toggle.textContent = open ? "상세" : "접기";
      });

      top.appendChild(left);
      top.appendChild(toggle);

      row.appendChild(top);
      row.appendChild(sub);
      host.appendChild(row);
    });

    openConfirm();
  }

  // ✅ 실행 버튼/Enter: 바로 추가/삭제 X → 확인 모달 오픈
  async function runUnifiedNlpAction(){
    const input = document.getElementById("nlp-unified-text");
    const toggle = document.getElementById("nlp-mode-toggle");
    const text = input?.value?.trim() ?? "";
    const imagePayload = getNlpImagePayload();

    const isDelete = !!toggle?.checked;
    if(isDelete){
      if(!text){
        showWarning("삭제할 문장을 입력해주세요.");
        return;
      }
    }else if(!text && imagePayload.length === 0){
      showWarning("문장이나 이미지를 입력해주세요.");
      return;
    }

    setUnifiedBusy(true);
    try{
      if(isDelete){
        const scope = getDeleteScopeOrAlert();
        if(!scope) return;
        await openDeleteConfirm(text, scope);
      }else{
        await openAddConfirm(text, imagePayload);
      }
    }catch(err){
      console.error(err);
      showWarning("실행 중 오류가 발생했습니다. 다시 시도해주세요.");
    }finally{
      setUnifiedBusy(false);
    }
  }

  document.addEventListener("DOMContentLoaded", () => {
    // Calendar init
    let calendarFadeTimer = null;
    const calendarContent = document.querySelector("#calendar-container .calendar-main-content");
    const calendarEl = document.getElementById("calendar");
    selectedDateStr = toDateStrLocal(new Date());
    setSelectedDate(selectedDateStr);
    initEventsPanelDock();
    requestAnimationFrame(updateViewSwitchIndicators);

    calendar = new FullCalendar.Calendar(calendarEl, {
      initialView:"dayGridMonth",
      locale:"ko",
      height:"auto",
      headerToolbar:false,
      fixedWeekCount:false,
      dayMaxEventRows:4,
      displayEventTime:false,

      dayCellClassNames: (arg) => {
        const ds = toDateStrLocal(arg.date);
        return (ds === selectedDateStr) ? ["selected-day"] : [];
      },
      dayCellContent: (arg) => String(arg.date.getDate()),
      dayHeaderClassNames: (arg) => {
        const ds = toDateStrLocal(arg.date);
        return (ds === selectedDateStr) ? ["selected-day-header"] : [];
      },

      events: async (info, success, failure) => {
        const formatLocalEvent = (ev) => {
          const rawStart = ev.start || "";
          const rawEnd = ev.end || null;
          const allDay = (ev.all_day === true) || isAllDayRange(rawStart, rawEnd);
          if(allDay){
            const startDateOnly = toDateOnly(rawStart) || toDateOnly(rawEnd) || "";
            const inclusiveEnd = toDateOnly(rawEnd) || startDateOnly;
            const exclusiveEnd = addDaysToDateStr(inclusiveEnd, 1) || addDaysToDateStr(startDateOnly, 1);
            const startValue = startDateOnly || toDateStrLocal(new Date());
            return {
              id:String(ev.id),
              title:ev.title,
              start:startValue,
              end:exclusiveEnd,
              allDay:true,
              extendedProps:{location: ev.location || "", allDay:true, source:"local"}
            };
          }
          return {
            id:String(ev.id),
            title:ev.title,
            start:rawStart,
            end:rawEnd || null,
            allDay:false,
            extendedProps:{location: ev.location || "", allDay:false, source:"local"}
          };
        };

        const formatGoogleEvent = (ev) => {
          const rawStart = ev.start || "";
          const rawEnd = ev.end || null;
          const allDay = !!ev.all_day;
          if(allDay){
            const startDateOnly = toDateOnly(rawStart) || toDateOnly(rawEnd) || "";
            const inclusiveEnd = toDateOnly(rawEnd) || startDateOnly;
            const exclusiveEnd = addDaysToDateStr(inclusiveEnd, 1) || addDaysToDateStr(startDateOnly, 1);
            return {
              id:ev.id,
              title: ev.title || "(제목 없음)",
              start:startDateOnly || rawStart,
              end:exclusiveEnd,
              allDay:true,
              extendedProps:{
                location: ev.location || "",
                allDay:true,
                source:"google",
                googleId: ev.google_event_id || ""
              }
            };
          }
          return {
            id:ev.id,
            title: ev.title || "(제목 없음)",
            start:rawStart,
            end:rawEnd || null,
            allDay:false,
            extendedProps:{
              location: ev.location || "",
              allDay:false,
              source:"google",
              googleId: ev.google_event_id || ""
            }
          };
        };

        try{
          const showLocal = !IS_GOOGLE_MODE;
          const showGoogle = IS_GOOGLE_MODE;
          const viewRange = getCalendarViewRange(info);
          const viewStartDate = viewRange.startDate;
          const viewEndDate = viewRange.endDate;
          const viewStartStr = viewRange.startStr;
          const viewEndStr = viewRange.endStr;

          let localEvents = [];
          if(showLocal){
            const data = await getLocalEventsForRange(viewStartStr, viewEndStr);
            localEvents = Array.isArray(data) ? data.map(formatLocalEvent) : [];
          }

          let googleEvents = [];
          if(showGoogle){
            const years = [];
            const startYear = viewStartDate.getFullYear();
            const endYear = viewEndDate.getFullYear();
            for(let y = startYear; y <= endYear; y += 1){
              years.push(y);
            }
            await ensureGoogleEventsForYears(years);
            const cachedRange = collectGoogleEventsBetween(viewStartStr, viewEndStr);
            googleEvents = cachedRange.map(formatGoogleEvent);
          }

          success([...(localEvents || []), ...(googleEvents || [])]);
        }catch(err){
          console.error(err);
          failure(err);
        }
      },

      dateClick: (info) => {
        setSelectedDate(info.dateStr);
        loadEventListForDate(selectedDateStr);
      },

      eventClick: (info) => {
        const ev = info.event;
        openEventModal({
          id: ev.id,
          title: ev.title,
          start: ev.start ? ev.start.toISOString() : "",
          end: ev.end ? ev.end.toISOString() : "",
          location: ev.extendedProps.location,
          notes: "",
          source: ev.extendedProps.source || "local",
          googleId: ev.extendedProps.googleId || null,
          allDay: ev.allDay
        });
      },

      datesSet: (info) => {
        updateYearMonthLabel(info.view.calendar.getDate());
        setActiveView(info.view.type);
        syncSelectedDayHighlight();
        if(calendarContent){
          window.clearTimeout(calendarFadeTimer);
          calendarFadeTimer = window.setTimeout(() => {
            calendarContent.classList.remove("is-fading");
          }, 40);
        }
      },

      loading: (isLoading) => {
        if(!isLoading && !initialListLoaded){
          initialListLoaded = true;
          if(selectedDateStr){
            loadEventListForDate(selectedDateStr);
          }
        }
      }
    });

    calendar.render();
    syncSelectedDayHighlight();
    updateYearMonthLabel(calendar.getDate());
    setActiveView(calendar.view.type);

    calendarEl.addEventListener("dblclick", (event) => {
      const target = event.target;
      if(target.closest(".fc-event")) return;
      const dayCell = target.closest(".fc-daygrid-day");
      const timeCol = target.closest(".fc-timegrid-col");
      const dateStr = (dayCell && dayCell.getAttribute("data-date"))
        || (timeCol && timeCol.getAttribute("data-date"));
      if(!dateStr) return;
      setSelectedDate(dateStr);
      loadEventListForDate(dateStr);
      openCreateEventModal(dateStr);
    });

    const runCalendarFadeNav = (action) => {
      if(!calendarContent){
        action();
        return;
      }
      calendarContent.classList.add("is-fading");
      window.clearTimeout(calendarFadeTimer);
      calendarFadeTimer = window.setTimeout(() => {
        action();
        calendarFadeTimer = window.setTimeout(() => {
          calendarContent.classList.remove("is-fading");
        }, 40);
      }, 40);
    };

    // topbar controls
    yearViewYear = calendar.getDate().getFullYear();
    const isYearViewActive = () => document.getElementById("year-view")?.classList.contains("active");

    document.getElementById("cal-prev").addEventListener("click", () => {
      if(isYearViewActive()){
        refreshYearView(yearViewYear - 1);
        return;
      }
      runCalendarFadeNav(() => calendar.prev());
    });
    document.getElementById("cal-next").addEventListener("click", () => {
      if(isYearViewActive()){
        refreshYearView(yearViewYear + 1);
        return;
      }
      runCalendarFadeNav(() => calendar.next());
    });
    document.getElementById("cal-today").addEventListener("click", () => {
      if(isYearViewActive()){
        refreshYearView(new Date().getFullYear());
        return;
      }
      runCalendarFadeNav(() => {
        calendar.today();
        const d = toDateStrLocal(new Date());
        setSelectedDate(d);
        loadEventListForDate(d);
      });
    });

    const eventSearchWrap = document.querySelector(".event-search");
    const eventSearchInput = document.getElementById("event-search-input");
    const eventSearchRangeBack = document.getElementById("event-search-range-back");
    const eventSearchRangeForward = document.getElementById("event-search-range-forward");
    const eventSearchSettingsBtn = document.getElementById("event-search-settings-btn");
    const eventSearchRangeClose = document.getElementById("event-search-range-close");
    const eventSearchRangeApply = document.getElementById("event-search-range-apply");
    const eventSearchBtn = document.getElementById("event-search-btn");
    const setEventSearchOpen = (isOpen) => {
      if(!eventSearchWrap) return;
      eventSearchWrap.classList.toggle("is-open", !!isOpen);
    };
    const setRangeOpen = (isOpen) => {
      if(!eventSearchWrap) return;
      eventSearchWrap.classList.toggle("is-range-open", !!isOpen);
      if(isOpen){
        setEventSearchOpen(true);
      }
    };
    const readRangeValue = (input) => {
      if(!input) return 0;
      const raw = (input.value || "").trim();
      if(!raw) return 0;
      const num = parseInt(raw, 10);
      return Number.isFinite(num) ? num : 0;
    };
    const validateRangeInputs = () => {
      const backYears = readRangeValue(eventSearchRangeBack);
      const forwardYears = readRangeValue(eventSearchRangeForward);
      if(backYears < 0 || forwardYears < 0){
        showWarning("검색 범위는 0년 이상으로 입력해주세요.");
        return false;
      }
      if(backYears + forwardYears > 10){
        showWarning("검색 범위는 이전/이후 합산 10년까지 설정할 수 있습니다.");
        return false;
      }
      return true;
    };
    const runEventSearch = async () => {
      const query = normalizeSearchQuery(eventSearchInput?.value);
      if(!query){
        showWarning("검색어를 입력해주세요.");
        return;
      }
      if(!validateRangeInputs()){
        return;
      }
      const backYears = readRangeValue(eventSearchRangeBack);
      const forwardYears = readRangeValue(eventSearchRangeForward);
      const range = getCustomSearchRange(backYears, forwardYears);
      let candidates = [];
      try{
        if(IS_GOOGLE_MODE){
          const baseYear = calendar.getDate().getFullYear();
          let years = [];
          if(range && range.start && range.end){
            years = getYearsFromRange(range.start, range.end);
          }else{
            years = extractSearchYears(query, baseYear);
            if(years.length === 0 && Number.isFinite(baseYear)){
              years.push(baseYear);
            }
          }
          if(years.length === 0 && Number.isFinite(baseYear)){
            years.push(baseYear);
          }
          await ensureGoogleEventsForYears(years);
          candidates = years.flatMap((year) => (Array.isArray(googleEventCache[year]) ? googleEventCache[year] : []));
          if(range && range.start && range.end){
            candidates = candidates.filter((ev) => eventIntersectsRange(ev, range.start, range.end));
          }
        }else{
          if(range && range.start && range.end){
            candidates = await fetchLocalEventsBetween(range.start, range.end);
          }else{
            candidates = await fetchLocalEventsBetween(null, null);
          }
        }
      }catch(err){
        console.error(err);
        showWarning("검색 중 오류가 발생했습니다.");
        return;
      }
      const matches = candidates.filter((ev) => eventMatchesQuery(ev, query));
      if(matches.length === 0){
        showWarning("일정을 찾지 못했습니다.");
        return;
      }
      const best = pickBestMatch(matches);
      const targetDate = getEventDateStr(best);
      if(!targetDate){
        showWarning("이 일정의 날짜를 찾지 못했습니다.");
        return;
      }
      calendar.gotoDate(targetDate);
      setSelectedDate(targetDate);
      loadEventListForDate(targetDate);
    };
    if(eventSearchBtn){
      eventSearchBtn.addEventListener("click", () => {
        if(eventSearchWrap && !eventSearchWrap.classList.contains("is-open")){
          setEventSearchOpen(true);
          eventSearchInput?.focus();
          return;
        }
        runEventSearch();
      });
    }
    if(eventSearchSettingsBtn){
      eventSearchSettingsBtn.addEventListener("click", (e) => {
        e.preventDefault();
        setRangeOpen(!eventSearchWrap?.classList.contains("is-range-open"));
      });
    }
    if(eventSearchRangeClose){
      eventSearchRangeClose.addEventListener("click", () => {
        setRangeOpen(false);
      });
    }
    if(eventSearchRangeApply){
      eventSearchRangeApply.addEventListener("click", () => {
        if(!validateRangeInputs()){
          return;
        }
        setRangeOpen(false);
      });
    }
    if(eventSearchInput){
      eventSearchInput.addEventListener("focus", () => {
        setEventSearchOpen(true);
      });
      eventSearchInput.addEventListener("keydown", (e) => {
        if(e.key === "Enter"){
          e.preventDefault();
          runEventSearch();
        }else if(e.key === "Escape"){
          setRangeOpen(false);
          setEventSearchOpen(false);
          eventSearchInput.blur();
        }
      });
      eventSearchInput.addEventListener("blur", () => {
        setTimeout(() => {
          if(eventSearchWrap && document.activeElement && eventSearchWrap.contains(document.activeElement)){
            return;
          }
          if(!normalizeSearchQuery(eventSearchInput.value) && !eventSearchWrap?.classList.contains("is-range-open")){
            setEventSearchOpen(false);
          }
        }, 0);
      });
    }
    [eventSearchRangeBack, eventSearchRangeForward].forEach((input) => {
      if(!input) return;
      input.addEventListener("focus", () => {
        setEventSearchOpen(true);
      });
      input.addEventListener("blur", () => {
        validateRangeInputs();
      });
    });
    document.addEventListener("click", (event) => {
      if(!eventSearchWrap) return;
      if(eventSearchWrap.contains(event.target)) return;
      if(eventSearchWrap.classList.contains("is-range-open")){
        setRangeOpen(false);
      }
      if(eventSearchWrap.classList.contains("is-open") && !normalizeSearchQuery(eventSearchInput?.value)){
        setEventSearchOpen(false);
      }
    });
    document.addEventListener("keydown", (event) => {
      if(event.key !== "Escape") return;
      if(eventSearchWrap?.classList.contains("is-range-open")){
        setRangeOpen(false);
      }
    });

    document.querySelectorAll("[data-cal-view]").forEach(btn => {
      btn.addEventListener("click", () => {
        const view = btn.dataset.calView;
        if(view === "year"){
          setActiveView(view);
          const year = calendar.getDate().getFullYear();
          refreshYearView(year);
          setYearViewVisible(true, "year");
          return;
        }
        calendar.changeView(view);
        setActiveView(view);
        setYearViewVisible(false, view);
      });
    });

    // quick add
    // NLP auto-grow
    setupShadowAutoGrow("nlp-unified-text");
    const composerWrap = document.querySelector(".composer-input-wrap");
    if(composerWrap){
      requestAnimationFrame(() => {
        const rect = composerWrap.getBoundingClientRect();
        if(rect.height){
          composerWrap.style.setProperty("--composer-pill-radius", `${Math.round(rect.height / 2)}px`);
        }
      });
    }
    setupImageComposer();
    initReasoningEffortControl();
    setupEventModalControls();

    const toggle = document.getElementById("nlp-mode-toggle");
    const actionBtn = document.getElementById("nlp-action-btn");

    setUnifiedMode(toggle.checked);
    toggle.addEventListener("change", () => setUnifiedMode(toggle.checked));
    actionBtn.addEventListener("click", runUnifiedNlpAction);

    setDefaultDateRange("delete-scope-start", "delete-scope-end", 30);
    updateUndoButton();
    const undoBtn = document.getElementById("undo-last-btn");
    if(undoBtn){
      undoBtn.addEventListener("click", undoLastBatch);
    }

    const recentBtn = document.getElementById("recent-added-btn");
    if(recentBtn){
      recentBtn.style.display = "";
      recentBtn.addEventListener("click", openRecentModal);
    }

    const toolBtn = document.getElementById("tool-menu-btn");
    const toolDrawer = document.getElementById("tool-drawer");
    const toolOverlay = document.getElementById("tool-overlay");
    const toolClose = document.getElementById("tool-close-btn");
    const openToolDrawer = () => {
      if(!toolDrawer || !toolOverlay) return;
      toolDrawer.classList.add("active");
      toolOverlay.classList.add("active");
      document.body.classList.add("drawer-open");
    };
    const closeToolDrawer = () => {
      if(!toolDrawer || !toolOverlay) return;
      toolDrawer.classList.remove("active");
      toolOverlay.classList.remove("active");
      document.body.classList.remove("drawer-open");
    };
    toolBtn?.addEventListener("click", openToolDrawer);
    toolOverlay?.addEventListener("click", closeToolDrawer);
    toolClose?.addEventListener("click", closeToolDrawer);
    document.addEventListener("keydown", (e) => {
      if(e.key === "Escape"){
        closeToolDrawer();
      }
    });
    window.addEventListener("resize", () => {
      requestAnimationFrame(updateViewSwitchIndicators);
    });

    const ta = document.getElementById("nlp-unified-text");
    if(ta){
      ta.addEventListener("compositionstart", () => { nlpInputComposing = true; });
      ta.addEventListener("compositionend", () => { nlpInputComposing = false; });
      ta.addEventListener("blur", () => { nlpInputComposing = false; });

      ta.addEventListener("keydown", (e) => {
        if(e.key === "Enter" && !e.shiftKey){
          if(e.isComposing || nlpInputComposing) return;
          e.preventDefault();
          runUnifiedNlpAction();
        }
      });
    }

    // pill placeholders
    function setupPillPlaceholder(inputId){
      const input = document.getElementById(inputId);
      const wrap = input?.closest(".pill-field");
      const ph = wrap?.querySelector(".pill-placeholder");
      if(!input || !ph) return;

      const update = () => {
        if(input.value && input.value.trim() !== ""){
          ph.classList.add("hidden");
          input.classList.add("has-value");
        }else{
          ph.classList.remove("hidden");
          input.classList.remove("has-value");
        }
      };
      input.addEventListener("input", update);
      input.addEventListener("change", update);
      update();
    }
    setupPillPlaceholder("start");
    setupPillPlaceholder("end");
    setupPillPlaceholder("location");

    // confirm modal bindings
    document.getElementById("confirm-close").addEventListener("click", closeConfirm);
    document.getElementById("confirm-cancel").addEventListener("click", closeConfirm);
    document.getElementById("confirm-overlay").addEventListener("click", (e) => {
      if(e.target && e.target.id === "confirm-overlay") closeConfirm();
    });

    document.getElementById("recent-close").addEventListener("click", closeRecentModal);
    document.getElementById("recent-cancel").addEventListener("click", closeRecentModal);
    document.getElementById("recent-overlay").addEventListener("click", (e) => {
      if(e.target && e.target.id === "recent-overlay") closeRecentModal();
    });

    document.getElementById("confirm-ok").addEventListener("click", async () => {
      if(confirmState.mode === "add"){
        const topChecks = Array.from(document.querySelectorAll("input[type=checkbox][data-role='add-top']"));
        const chosenIdx = topChecks
          .filter(x => x.checked)
          .map(x => parseInt(x.dataset.addIndex, 10))
          .filter(n => Number.isFinite(n));

        const occSelected = {};
        document.querySelectorAll("input[type=checkbox][data-role='add-occurrence']").forEach(el => {
          const addIdx = parseInt(el.dataset.addIndex || "", 10);
          const occIdx = parseInt(el.dataset.addOccurrenceIndex || "", 10);
          if(!Number.isFinite(addIdx) || !Number.isFinite(occIdx)) return;
          if(!occSelected[addIdx]) occSelected[addIdx] = [];
          if(el.checked){
            occSelected[addIdx].push(occIdx);
          }
        });

        const selectedEntries = [];
        chosenIdx.forEach(idx => {
          const base = confirmState.addItems[idx];
          if(!base) return;

          if((base.type || "").toLowerCase() === "recurring"){
            const occList = occSelected[idx];
            if(Array.isArray(occList) && occList.length > 0){
              selectedEntries.push({ idx, item: { ...base, selected_occurrence_indexes: occList } });
              return;
            }
            if(occSelected[idx] === undefined){
              selectedEntries.push({ idx, item: base });
              return;
            }
            return;
          }
          selectedEntries.push({ idx, item: base });
        });

        const selected = selectedEntries.map(entry => entry.item);

        if(selected.length === 0){
          showWarning("추가할 항목을 선택해주세요.");
          return;
        }

        for(const entry of selectedEntries){
          const original = confirmState.addItems[entry.idx];
          if(original && original.requires_end_confirmation){
            const selection = getRecurrenceEndSelection(entry.idx);
            if(!selection){
              showWarning("반복 종료 방식을 선택해주세요.");
              return;
            }
            if(selection.mode === "until" && !selection.value){
              showWarning("반복 종료 날짜를 입력해주세요.");
              return;
            }
            if(selection.mode === "count" && (!selection.value || selection.value <= 0)){
              showWarning("반복 횟수를 1 이상으로 입력해주세요.");
              return;
            }
            entry.item.recurring_end_override = selection;
          }
        }

        const res = await fetch(apiBase + "/nlp-apply-add", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ items: selected })
        });

        if(!res.ok){
          showWarning("일정 추가 적용에 실패했습니다.");
          return;
        }
        const created = await res.json();
        if(Array.isArray(created)){
          recordUndoBatch(created);
        }
        if(IS_GOOGLE_MODE){
          markGoogleCacheDirty();
        }else{
          markLocalCacheDirty();
        }

        closeConfirm();
        resetNlpComposerInputs();
        resetNlpConversation();
        await refreshAll();
        return;
      }

      if(confirmState.mode === "delete"){
        const ids = Array.from(document.querySelectorAll("input[type=checkbox][data-delete-id]"))
          .filter(x => x.checked)
          .map(x => parseInt(x.dataset.deleteId, 10))
          .filter(n => Number.isFinite(n));

        if(ids.length === 0){
          showWarning("삭제할 항목을 선택해주세요.");
          return;
        }

        const res = await fetch(apiBase + "/delete-by-ids", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ ids })
        });

        if(!res.ok){
          showWarning("일정 삭제 적용에 실패했습니다.");
          return;
        }
        markLocalCacheDirty();

        closeConfirm();
        resetNlpComposerInputs();
        await refreshAll();
        return;
      }
    });
  });
</script>
</body>
</html>
